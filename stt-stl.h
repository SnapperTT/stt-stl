// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// config.hh
//

#ifndef LZZ_config_hh
#define LZZ_config_hh
// Config for stt-stl
#include <cstring>	// memcpy, etc
#include <cstdint>	// uint64_t, etc
#include <type_traits>	// needed for template stuff
#include <cstdlib>	// malloc
#include <utility>	// std::move
#include <initializer_list> // constructors, etc
#include <iterator> // std::move_iterator
#include <cstdarg> // varadic arguments

// For detection of this lib
#define STT_STL_LIB 1

// Options
#ifndef STT_STL_DEBUG
	#define STT_STL_DEBUG 0
#endif
#ifndef STT_STL_DEBUG_MEMORY
	#define STT_STL_DEBUG_MEMORY 0
#endif

// default allocator macro
// - must be a pointer to a stt::allocatorI
// - must be valid at compile time
// - must be aware of static initialisation order issues
// - (in C++ static initialisation order is not defined)
#ifndef STT_STL_DEFAULT_ALLOCATOR
	#define STT_STL_DEFAULT_ALLOCATOR ( crt_allocator::getStaticCrtAllocator() )
#endif

// Assert
#ifndef STT_STL_ASSERT
	#define STT_STL_ASSERT(X,M) assert(X && M)
	#include <assert.h>
#endif

#ifndef STT_STL_ABORT
	#define STT_STL_ABORT abort
#endif

// printf
#ifndef STT_STL_PRINT
	#define STT_STL_PRINT(X) printf("%s", X)
#endif

// debug page
#ifndef STT_STL_DEBUG_PAGE
	#define STT_STL_DEBUG_PAGE 0
#endif

#ifndef STT_STL_USE_STD_SPAN_IF_AVAILIABLE
	#define STT_STL_USE_STD_SPAN_IF_AVAILIABLE 1
#endif

// track  page allocations - if STT_STL_DEBUG_PAGE is on then
// force enable STT_STL_TRACK_SYSTEM_ALLOCATIONS
#ifndef STT_STL_TRACK_SYSTEM_ALLOCATIONS
	#define STT_STL_TRACK_SYSTEM_ALLOCATIONS STT_STL_DEBUG_PAGE
#else
	#if STT_STL_DEBUG_PAGE
		#undef STT_STL_TRACK_SYSTEM_ALLOCATIONS
		#define STT_STL_TRACK_SYSTEM_ALLOCATIONS STT_STL_DEBUG_PAGE
	#endif
#endif

// Size types
// define the macro to if you wish to override with your own types
#ifndef STT_STL_SIZE_TYPES
	#define STT_STL_SIZE_TYPES
	namespace stt {
		typedef uint32_t storage_size_t;
		typedef uint64_t alloc_size_t;
		typedef uint64_t string_size_t;
		}
#endif

// Span
// uncomment to use std::span instead of stt::span
//#define STT_STL_SPAN std::span 

// Likley
#ifndef STT_STL_LIKLEY
	#if __cplusplus >= 202002L
		#define STT_STL_LIKLEY(cond) [[likely]] (cond)
	#else
		#define STT_STL_LIKLEY(cond) (__builtin_expect(!!(cond), 1))
	#endif
#endif

#ifndef STT_STL_UNLIKLEY
	#if __cplusplus >= 202002L
		#define STT_STL_UNLIKLEY(cond) [[unlikely]] (cond)
	#else
		#define STT_STL_UNLIKLEY(cond) (__builtin_expect(!!(cond), 0))
	#endif
#endif

#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_config
#define STT_STL_IMPL_DOUBLE_GUARD_config
#define LZZ_OVERRIDE
// config.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_config
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// common.hh
//

#ifndef LZZ_common_hh
#define LZZ_common_hh
namespace stt {
	struct sso_pod_tag { uint8_t _padding; };
	struct sso_null_terminated_pod_tag { uint8_t _padding; };
		
	// Templates
	// std can only be referenced from here
	// if for whatever reason you don't want to use std then provide your own definitions
	template<class T, class V>
	using is_same = std::is_same<T,V>;
		
	template <typename T>
	using is_pod = std::is_trivially_copyable<T>;
	
	// alias for is_pod<> implementation
	template <typename T>
	using pod_proxy = typename std::conditional<stt::is_pod<T>::value, sso_pod_tag, T>::type;
	
	template <typename T>
	using initializer_list = std::initializer_list<T>;
	
	template <typename T>
	using move_iterator = std::move_iterator<T>;
	
	template <typename T>
	using reverse_iterator = std::reverse_iterator<T>;
	
	template <typename T>
	using requires_fill_on_resize = std::integral_constant<bool,!std::is_trivially_default_constructible<T>::value>;
	
	template <typename T>
	using requires_destroy_on_resize = std::integral_constant<bool,!std::is_trivially_destructible<T>::value>;
	}
#define LZZ_INLINE inline
namespace stt
{
  void stt_memcpy (uint8_t * __dst, uint8_t const * __src, storage_size_t const __n);
}
namespace stt
{
  void stt_memmove (uint8_t * __dst, uint8_t const * __src, storage_size_t const __n);
}
namespace stt
{
  void stt_memset (uint8_t * __dst, int __c, storage_size_t const __n);
}
namespace stt
{
  storage_size_t stt_strlen (char const * __s);
}
namespace stt
{
  void * stt_malloc (uint64_t const __size);
}
namespace stt
{
  void stt_free (void * __ptr);
}
namespace stt
{
  void stt_dbg_log (char const * fmt, ...);
}
namespace stt
{
  uint64_t hash_low (uint64_t const seed, uint8_t const * ptr, alloc_size_t const size);
}
namespace stt
{
  uint64_t hash_high (uint64_t const seed, uint64_t const * ptr, alloc_size_t const size);
}
namespace stt
{
  uint64_t hash_function_big (uint8_t const * ptr, alloc_size_t const size);
}
namespace stt
{
  uint64_t hash_function (uint8_t const * ptr, alloc_size_t const size);
}
namespace stt
{
  template <typename T>
  void objectFillRange (T * start, T * end);
}
namespace stt
{
  template <typename T>
  void objectFillRangeInPlace (T * start, T * end);
}
namespace stt
{
  template <typename T>
  void objectFillRangeValue (T * start, T * end, T const & value);
}
namespace stt
{
  template <typename T>
  void objectFillRangeValueInPlace (T * start, T * end, T const & value);
}
namespace stt
{
  template <typename T>
  void objectDestroyRange (T * start, T * end);
}
namespace stt
{
  template <typename T>
  void objectCopyRange (T * dst, T const * start, T const * end);
}
namespace stt
{
  template <typename T>
  void objectCopyRangeInPlace (T * dst, T const * start, T const * end);
}
namespace stt
{
  template <typename T>
  void objectMoveRange (T * dst, T * start, T * end);
}
namespace stt
{
  template <typename T>
  void objectMoveRangeInPlace (T * dst, T * start, T * end);
}
namespace stt
{
  template <typename T>
  void objectMoveRangeReverse (T * dst, T * start, T * end);
}
namespace stt
{
  namespace error
  {
    void array_out_of_bounds (storage_size_t const index, storage_size_t const size);
  }
}
namespace stt
{
  namespace error
  {
    void bad_alloc (alloc_size_t const size, char const * message);
  }
}
namespace stt
{
  LZZ_INLINE void stt_memcpy (uint8_t * __dst, uint8_t const * __src, storage_size_t const __n)
                                                                                               {
		// Raw bytes memcpy
		memcpy(__dst,  __src, __n);
		}
}
namespace stt
{
  LZZ_INLINE void stt_memmove (uint8_t * __dst, uint8_t const * __src, storage_size_t const __n)
                                                                                                {
		// Raw bytes memcpy
		memmove(__dst,  __src, __n);
		}
}
namespace stt
{
  LZZ_INLINE void stt_memset (uint8_t * __dst, int __c, storage_size_t const __n)
                                                                                  {
		// Raw bytes memcpy
		memset(__dst,  __c, __n);
		}
}
namespace stt
{
  LZZ_INLINE storage_size_t stt_strlen (char const * __s)
                                                           {
		return strlen(__s);
		}
}
namespace stt
{
  LZZ_INLINE void * stt_malloc (uint64_t const __size)
                                                       {
		return malloc(__size);
		}
}
namespace stt
{
  LZZ_INLINE void stt_free (void * __ptr)
                                          {
		free(__ptr);
		}
}
namespace stt
{
  LZZ_INLINE uint64_t hash_function (uint8_t const * ptr, alloc_size_t const size)
                                                                                   {
		// for big buffers parse it 8 bytes at a time
		if (size > 8)
			return hash_function_big(ptr, size);
		else
			return hash_low(0, ptr, size); 
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectFillRange (T * start, T * end)
                                                      {
		for (T* tPtr = start; tPtr != end; tPtr++)
			new (tPtr) T();
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectFillRangeInPlace (T * start, T * end)
                                                             {
		objectFillRange(start, end);
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectFillRangeValue (T * start, T * end, T const & value)
                                                                           {
		for (T* tPtr = start; tPtr != end; tPtr++)
			*tPtr = value;
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectFillRangeValueInPlace (T * start, T * end, T const & value)
                                                                                  {
		for (T* tPtr = start; tPtr != end; tPtr++)
			new (tPtr) T(value);
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectDestroyRange (T * start, T * end)
                                                         {
		for (T* tPtr = start; tPtr != end; tPtr++)
			tPtr->~T();
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectCopyRange (T * dst, T const * start, T const * end)
                                                                          {
		// Memcpy for objects
		for (const T* tPtr = start; tPtr != end; tPtr++, dst++)
			*dst = *tPtr;
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectCopyRangeInPlace (T * dst, T const * start, T const * end)
                                                                                 {
		// Memcpy for objects
		for (const T* tPtr = start; tPtr != end; tPtr++, dst++)
			new (dst) T(*tPtr);
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectMoveRange (T * dst, T * start, T * end)
                                                              {
		// Memmove for objects
		for (T* tPtr = start; tPtr != end; tPtr++, dst++)
			*dst = std::move(*tPtr);
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectMoveRangeInPlace (T * dst, T * start, T * end)
                                                                     {
		// Memmove for objects
		for (T* tPtr = start; tPtr != end; tPtr++, dst++)
			new(dst) T(std::move(*tPtr));
		}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void objectMoveRangeReverse (T * dst, T * start, T * end)
                                                                     {
		// Memmove for objects
		for (T* tPtr = start; tPtr != end; tPtr--, dst--)
			*dst = std::move(*tPtr);
		}
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_common
#define STT_STL_IMPL_DOUBLE_GUARD_common
#define LZZ_OVERRIDE
// common.cpp
//

#define LZZ_INLINE inline
namespace stt
{
  void stt_dbg_log (char const * fmt, ...)
                                               {
		// wraps printf so it can be overriden by another logging funciton
		const uint32_t buffSz = 1024;
		char buff[buffSz];
		
		va_list args;
		va_start(args, fmt);
		vsnprintf(buff, buffSz-1, fmt, args);
		va_end(args);
		
		STT_STL_PRINT(buff);
		}
}
namespace stt
{
  uint64_t hash_low (uint64_t const seed, uint8_t const * ptr, alloc_size_t const size)
                                                                                            {
		// Implementation based on tinyStl::hash
		// https://github.com/mendsley/tinystl/blob/master/include/TINYSTL/hash.h
		// which is in turn based on an implementation of sdbm a public domain
		// string hash from Ozan Yigit
		// see: http://www.eecs.harvard.edu/margo/papers/usenix91/paper.ps
		uint64_t r = seed;
		for (const uint8_t* itt = ptr; itt != ptr+size; ++itt)
			r = (*itt) + (r << 6) + (r << 16) - r;
		return r;
		}
}
namespace stt
{
  uint64_t hash_high (uint64_t const seed, uint64_t const * ptr, alloc_size_t const size)
                                                                                              {
		// same as above but does 8 bytes at a time
		uint64_t r = seed;
		for (const uint64_t* itt = ptr; itt != ptr+size; ++itt)
			r = (*itt) + (r << 6) + (r << 16) - r;
		return r;
		}
}
namespace stt
{
  uint64_t hash_function_big (uint8_t const * ptr, alloc_size_t const size)
                                                                                {
		const alloc_size_t sz8 = (size-1) / 8;
		uint64_t r = hash_high(0, (const uint64_t*) ptr, sz8);
		return hash_low(r, ptr + 8*sz8, size - 8*sz8);
		}
}
namespace stt
{
  namespace error
  {
    void array_out_of_bounds (storage_size_t const index, storage_size_t const size)
                                                                                                {
			STT_STL_ASSERT(0, "index < size");
			}
  }
}
namespace stt
{
  namespace error
  {
    void bad_alloc (alloc_size_t const size, char const * message)
                                                                             {
			STT_STL_ASSERT(0, "index < size (check message)");
			}
  }
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_common
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// allocator.hh
//

#ifndef LZZ_allocator_hh
#define LZZ_allocator_hh
namespace stt {
	class allocatorI;
	}
#define LZZ_INLINE inline
namespace stt
{
  class allocatorI
  {
  public:
    allocatorI ();
    virtual ~ allocatorI ();
    virtual uint8_t * allocate (alloc_size_t const size) noexcept = 0;
    virtual void deallocate (uint8_t * ptr, alloc_size_t const size) noexcept = 0;
    virtual bool try_realloc (uint8_t * ptr, alloc_size_t const oldSize, alloc_size_t const newSize) noexcept;
    virtual alloc_size_t getNextCapacity (alloc_size_t const minSizeBytes) const;
  };
}
namespace stt
{
  class crt_allocator : public allocatorI
  {
  public:
    static crt_allocator * getStaticCrtAllocator ();
    crt_allocator ();
    uint8_t * allocate (alloc_size_t const size) noexcept LZZ_OVERRIDE;
    void deallocate (uint8_t * ptr, alloc_size_t const size) noexcept LZZ_OVERRIDE;
  };
}
namespace stt
{
  class null_view_allocator : public allocatorI
  {
  public:
    static null_view_allocator m_static_null_view_allocator;
    uint8_t * allocate (alloc_size_t const size) noexcept LZZ_OVERRIDE;
    void deallocate (uint8_t * ptr, alloc_size_t const size) noexcept LZZ_OVERRIDE;
  };
}
namespace stt
{
  class bump_allocator : public allocatorI
  {
  public:
    uint8_t * mBuff;
    alloc_size_t mSize;
    alloc_size_t mSeek;
    allocatorI * fallback;
    bump_allocator ();
    void bind (uint8_t * buffer, alloc_size_t bufferSize);
    uint8_t * allocate (alloc_size_t const size) noexcept LZZ_OVERRIDE;
    void deallocate (uint8_t * ptr, alloc_size_t const size) noexcept LZZ_OVERRIDE;
    bool try_realloc (uint8_t * ptr, alloc_size_t const oldSize, alloc_size_t const newSize) noexcept LZZ_OVERRIDE;
  };
}
namespace stt
{
  template <unsigned int SIZE>
  class auto_bump_allocator : public bump_allocator
  {
  public:
    uint8_t (buff) [SIZE];
    auto_bump_allocator ();
  };
}
namespace stt
{
  typedef auto_bump_allocator <4096> auto_bump_allocator4096;
}
namespace stt
{
  LZZ_INLINE bool allocatorI::try_realloc (uint8_t * ptr, alloc_size_t const oldSize, alloc_size_t const newSize) noexcept
                                                                                                                                 {
			// tries to resize an allocation, if it cannot be done then returns false
			// if the allocation is resized then ptr is unchanged
			return false;
			}
}
namespace stt
{
  LZZ_INLINE alloc_size_t allocatorI::getNextCapacity (alloc_size_t const minSizeBytes) const
                                                                                                   { return minSizeBytes * 2; }
}
namespace stt
{
  LZZ_INLINE crt_allocator::crt_allocator ()
                                       {}
}
namespace stt
{
  LZZ_INLINE bump_allocator::bump_allocator ()
    : mBuff (NULL), mSize (0), mSeek (0), fallback (NULL)
                                                                                          {}
}
namespace stt
{
  template <unsigned int SIZE>
  auto_bump_allocator <SIZE>::auto_bump_allocator ()
    : bump_allocator ()
                                                          {
			bind(&buff[0], SIZE);
			fallback = STT_STL_DEFAULT_ALLOCATOR ;
			}
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_allocator
#define STT_STL_IMPL_DOUBLE_GUARD_allocator
#define LZZ_OVERRIDE
// allocator.cpp
//

#define LZZ_INLINE inline
namespace stt
{
  allocatorI::allocatorI ()
                             {}
}
namespace stt
{
  allocatorI::~ allocatorI ()
                                      {}
}
namespace stt
{
  crt_allocator * crt_allocator::getStaticCrtAllocator ()
                                                              { static crt_allocator s; return &s; }
}
namespace stt
{
  uint8_t * crt_allocator::allocate (alloc_size_t const size) noexcept LZZ_OVERRIDE
                                                                              { return (uint8_t*) stt_malloc(size); }
}
namespace stt
{
  void crt_allocator::deallocate (uint8_t * ptr, alloc_size_t const size) noexcept LZZ_OVERRIDE
                                                                                          { if (ptr) stt_free(ptr); }
}
namespace stt
{
  null_view_allocator null_view_allocator::m_static_null_view_allocator;
}
namespace stt
{
  uint8_t * null_view_allocator::allocate (alloc_size_t const size) noexcept LZZ_OVERRIDE
                                                                              { STT_STL_ASSERT(false, "cannot allocate as this is for marking read-only objecets"); return NULL; }
}
namespace stt
{
  void null_view_allocator::deallocate (uint8_t * ptr, alloc_size_t const size) noexcept LZZ_OVERRIDE
                                                                                          {}
}
namespace stt
{
  void bump_allocator::bind (uint8_t * buffer, alloc_size_t bufferSize)
                                                                    {
			mBuff = buffer;
			mSize = bufferSize;
			}
}
namespace stt
{
  uint8_t * bump_allocator::allocate (alloc_size_t const size) noexcept LZZ_OVERRIDE
                                                                              {
		//	stt_dbg_log ("sst alloc %p, addr: %p, sz %i, [%i/%i]", this, r, int(size), int(mSize), int(mSeek));
			if (mSeek + size <= mSize) {
				uint8_t* r = &mBuff[mSeek];
				mSeek += size;
				return r;
				}
			else {
				uint8_t* r =  fallback ? fallback->allocate(size) : NULL; // bad alloc, out of buffer size
				stt_dbg_log ("sst alloc FALLBACK %p, addr: %p, sz %i, [%i/%i]", this, r, int(size), int(mSize), int(mSeek));
				return r;
				}
			}
}
namespace stt
{
  void bump_allocator::deallocate (uint8_t * ptr, alloc_size_t const size) noexcept LZZ_OVERRIDE
                                                                                          {
			//stt_dbg_log ("sst free %p, addr: %p, sz %i, [%i/%i]", this, ptr, int(size), int(mSize), int(mSeek));
			uintptr_t ptrT = (uintptr_t) ptr;
			uintptr_t begin = (uintptr_t) mBuff;
			uintptr_t end = begin + mSize;
			
			if (ptrT >= begin && ptrT < end) {
				// belongs to buffer
				if (ptrT == begin + mSeek - size) {
					// restore bump
					mSeek -= size;
					}
				return; // deallocating a bump allocator is a no-op
				}
			else {
				if (fallback)
					fallback->deallocate(ptr, size);
				}
			}
}
namespace stt
{
  bool bump_allocator::try_realloc (uint8_t * ptr, alloc_size_t const oldSize, alloc_size_t const newSize) noexcept LZZ_OVERRIDE
                                                                                                                           {
			uintptr_t ptrT = (uintptr_t) ptr;
			uintptr_t begin = (uintptr_t) mBuff;
			uintptr_t end = begin + mSize;
			
			if (ptrT >= begin && ptrT < end) {
				if (ptrT == begin + mSeek - oldSize) {
					if (mSeek - oldSize + newSize <= mSize) {
						mSeek += (newSize - oldSize);
						return true;
						}
					}
				}
			return false;
			}
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_allocator
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// span.hh
//

#ifndef LZZ_span_hh
#define LZZ_span_hh
namespace stt {
#if __has_include(<span>) && defined(__cplusplus) && __cplusplus >= 202002L && STT_STL_USE_STD_SPAN_IF_AVAILIABLE
	using span = std::span;
#else
	// Custom span replacement for C++17 and earlier
	template <typename T>
	class span {
	public:
		using element_type = T;
		using value_type = std::remove_cv_t<T>;
		using size_type = std::size_t;
		using difference_type = std::ptrdiff_t;
		using pointer = T*;
		using reference = T&;
		using iterator = T*;
		using const_iterator = const T*;

		constexpr span() noexcept : ptr_(nullptr), size_(0) {}
		constexpr span(T* ptr, size_type size) noexcept : ptr_(ptr), size_(size) {}
		
		template <std::size_t N>
		constexpr span(T (&arr)[N]) noexcept : ptr_(arr), size_(N) {}
		
		template <typename Container,
				  typename = std::enable_if_t<!std::is_array_v<Container> && std::is_convertible_v<decltype(std::declval<Container&>().data()), T*>>>
		constexpr span(Container& container) noexcept : ptr_(container.data()), size_(container.size()) {}

		constexpr size_type size() const noexcept { return size_; }
		constexpr bool empty() const noexcept { return size_ == 0; }

		constexpr T& operator[](size_type index) const { return ptr_[index]; }
		constexpr T* data() const noexcept { return ptr_; }

		constexpr iterator begin() const noexcept { return ptr_; }
		constexpr iterator end() const noexcept { return ptr_ + size_; }
		
		constexpr span<T> first(size_type count) const noexcept { return {ptr_, count}; }
		constexpr span<T> last(size_type count) const noexcept { return {ptr_ + (size_ - count), count}; }
		constexpr span<T> subspan(size_type offset, size_type count = static_cast<size_type>(-1)) const noexcept {
			return {ptr_ + offset, (count == static_cast<size_type>(-1)) ? size_ - offset : count};
		}

	protected:
		T* ptr_;
		size_type size_;
		};
#endif // __has_include(<span>) && defined(__cplusplus) && __cplusplus >= 202002L
}
#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_span
#define STT_STL_IMPL_DOUBLE_GUARD_span
#define LZZ_OVERRIDE
// span.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_span
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// storage.hh
//

#ifndef LZZ_storage_hh
#define LZZ_storage_hh
#define STT_ARRAY_CAST(_T, _ptr, _idx)  &(((_T*) _ptr)[_idx])
#define LZZ_INLINE inline
namespace stt
{
  class storage
  {
  public:
    allocatorI * mAllocator;
    uint8_t * ptr;
    storage_size_t size;
    storage_size_t capacity;
    void initToZero ();
    allocatorI * wrangleAllocator ();
    void setAllocator (allocatorI * alloc);
    void deallocate ();
    static storage_size_t calcualteNextCapacity (allocatorI const * const customAllocator, storage_size_t const currentCapacity, storage_size_t const minNewCapacity, storage_size_t const stride);
    template <typename T>
    void growCapacity (storage_size_t const wantsCapacityBytes, T * _unused);
    template <typename T>
    void growCapacity_impl (storage_size_t const wantsCapacityBytes, T * _unused);
    void growCapacity_impl (storage_size_t const wantsCapacityBytes, sso_null_terminated_pod_tag * _unused);
    void growCapacity_impl (storage_size_t const wantsCapacityBytes, sso_pod_tag * _unused);
    template <typename T>
    void shrink_to_fit (T * _unused);
    void dbg_printf () const;
  };
}
namespace stt
{
  LZZ_INLINE void storage::initToZero ()
                                         {
			ptr = NULL;
			size = 0;
			capacity = 0; 
			mAllocator = NULL;
			}
}
namespace stt
{
  LZZ_INLINE allocatorI * storage::wrangleAllocator ()
                                                      {
			return mAllocator ? mAllocator : ( STT_STL_DEFAULT_ALLOCATOR );
			}
}
namespace stt
{
  template <typename T>
  void storage::growCapacity (storage_size_t const wantsCapacityBytes, T * _unused)
                                                                                       {
			if (capacity >= wantsCapacityBytes) return;
			growCapacity_impl(wantsCapacityBytes, _unused);
			}
}
namespace stt
{
  template <typename T>
  void storage::growCapacity_impl (storage_size_t const wantsCapacityBytes, T * _unused)
                                                                                            {
			//printf("growCapacity #1 (%i -> %i)\n", capacity, wantsCapacityBytes);
			
			allocatorI * a = wrangleAllocator();
			if (a->try_realloc(ptr, capacity, wantsCapacityBytes)) {
				capacity = wantsCapacityBytes;
				return;
				}
			
			// realloc
			uint8_t* oldPtr = ptr;
			ptr = a->allocate(wantsCapacityBytes);
			if (oldPtr) {
				T* oldPtrT = (T*) oldPtr;
				objectMoveRangeInPlace((T*) ptr, oldPtrT, &oldPtrT[size/sizeof(T)]);
				a->deallocate(oldPtr, capacity);
				}
			capacity = wantsCapacityBytes;
			}
}
namespace stt
{
  LZZ_INLINE void storage::growCapacity_impl (storage_size_t const wantsCapacityBytes, sso_null_terminated_pod_tag * _unused)
                                                                                                                             {
			return growCapacity_impl(wantsCapacityBytes, (sso_pod_tag*) _unused);
			}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE void storage::shrink_to_fit (T * _unused)
                                                      {
			growCapacity_impl(size, (T*) _unused);
			}
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_storage
#define STT_STL_IMPL_DOUBLE_GUARD_storage
#define LZZ_OVERRIDE
// storage.cpp
//

static_assert(sizeof(stt::storage) == 16 + sizeof(stt::storage_size_t)*2);
#define LZZ_INLINE inline
namespace stt
{
  void storage::setAllocator (allocatorI * alloc)
                                                     {
			// You can only set an allocator once as swapping
			// allocators is undefined behaviour
			STT_STL_ASSERT(mAllocator != NULL, "Allocator is already set!");
			mAllocator = alloc;
			}
}
namespace stt
{
  void storage::deallocate ()
                                  {
			wrangleAllocator()->deallocate(ptr, capacity);
			size = 0;
			capacity = 0;
			ptr = NULL;
			}
}
namespace stt
{
  storage_size_t storage::calcualteNextCapacity (allocatorI const * const customAllocator, storage_size_t const currentCapacity, storage_size_t const minNewCapacity, storage_size_t const stride)
                                                                                                                                                                                                             {//, const allocatorI * allocator) {
			// Applies a growth factor to capacity
			if (minNewCapacity > currentCapacity*2) {
				return minNewCapacity; 
				}
			if (minNewCapacity > currentCapacity) {
				if (customAllocator) // custom allocators might need special considerations (eg, not allocating just above the size of an internall buffer just to get a 2x growth)
					return customAllocator->getNextCapacity(minNewCapacity);
				return currentCapacity*2;
				}
			return currentCapacity;
			}
}
namespace stt
{
  void storage::growCapacity_impl (storage_size_t const wantsCapacityBytes, sso_pod_tag * _unused)
                                                                                                      {
			//printf("growCapacity #2 (%i -> %i)\n", capacity, wantsCapacityBytes);
			
			allocatorI * a = wrangleAllocator();
			if (a->try_realloc(ptr, capacity, wantsCapacityBytes)) {
				capacity = wantsCapacityBytes;
				return;
				}

			// realloc
			uint8_t* oldPtr = ptr;
			ptr = a->allocate(wantsCapacityBytes);
			if (oldPtr) {
				stt_memcpy(ptr, oldPtr, size);
				a->deallocate(oldPtr, capacity);
				}
			capacity = wantsCapacityBytes;
			}
}
namespace stt
{
  void storage::dbg_printf () const
                                         {
			#if STT_STL_DEBUG
				// this generates compiler warnings on windows due to different format codes for integer sizes
				printf("mAllocator: %lx, ptr: %lx, size %i, capacity %i\n", (intptr_t) mAllocator, (intptr_t) ptr, size, capacity);
			#endif
			}
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_storage
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// sso.hh
//

#ifndef LZZ_sso_hh
#define LZZ_sso_hh
#ifdef STT_STL_DEBUG 
	#include <bitset>
#endif
#define LZZ_INLINE inline
namespace stt
{
  template <unsigned int N, typename T = sso_pod_tag, typename SSO_SIZE_T = uint8_t, bool IS_ALWAYS_STORE = false>
  class sso_base
  {
  public:
    union sso_u
    {
      storage store;
      uint8_t (sso) [N];
    };
    sso_u d;
    sso_base ();
    void init ();
    ~ sso_base ();
    void dbg_printf () const;
    void dbg_snprintf (char * buff, uint64_t sz) const;
    void dbg_dump_row () const;
    void dbg_dump () const;
    static constexpr bool isPod ();
    static constexpr bool isNullTerminatedPod ();
    static constexpr storage_size_t null_termination_padding ();
    static constexpr storage_size_t max_size ();
    static constexpr storage_size_t element_size ();
    static constexpr SSO_SIZE_T local_capcity ();
    static constexpr bool isAlwaysStore ();
    constexpr SSO_SIZE_T & local_size_ref ();
    constexpr SSO_SIZE_T const & local_size_ref_c () const;
    constexpr SSO_SIZE_T sso_size_flag () const;
    void enableSsoFlag ();
    void disableSsoFlag ();
    SSO_SIZE_T local_size () const;
    void set_local_size (storage_size_t const sz);
    bool useSso () const;
    uint8_t * data ();
    uint8_t const * data () const;
    storage_size_t size () const;
    storage_size_t capacity () const;
    void switchToStorage ();
    void setAllocator (allocatorI * alloc);
    void switchToStorage_impl (storage_size_t const wantsCapacityBytes, allocatorI * mAllocator);
    void switchToSso_impl ();
    uint8_t * reserve_impl_sso (storage_size_t const wantCapacityBytes, storage_size_t const incrSize = 0);
    uint8_t * reserve_impl_store (storage_size_t const wantCapacityBytes, storage_size_t const incrSize = 0);
    uint8_t * reserve (storage_size_t const wantCapacityBytes, storage_size_t const incrSize = 0);
    void resize (uint32_t const sizeInBytes);
    void resize_impl (uint32_t const sizeInBytes, bool const tfill = true);
    void fill_or_destroy_elements (uint8_t * dst, storage_size_t const oldSize, storage_size_t const newSize);
    void copy_elements (uint8_t * dst, uint8_t const * src, storage_size_t const num_elements_or_bytes);
    void copy_elements_in_place (uint8_t * dst, uint8_t const * src, storage_size_t const num_elements_or_bytes);
    void move_elements_in_place (uint8_t * dst, uint8_t * src, storage_size_t const num_elements_or_bytes);
    void fill_elements_in_place (uint8_t * dst, storage_size_t const num_elements_or_bytes);
    void destroy_elements ();
    void destroy_elements_impl ();
    void clear ();
    void clearAndDeallocate ();
    void shrink_to_fit ();
  };
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::sso_base ()
                                  { init(); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::init ()
                                   {
			#ifdef STT_STL_DEBUG
				#if STT_STL_DEBUG > 1
					printf("construct sso_base: %p %s\n", this, __PRETTY_FUNCTION__);
				#endif
			#endif
			#if STT_STL_DEBUG_MEMORY
				// poison this so that null-termination errors
				// become visible
				memset(this, 0xbaadf88d, sizeof(*this));
			#endif
			
			if constexpr (isAlwaysStore()) {
				d.store.initToZero();
				disableSsoFlag();
				}
			else {
				d.store.initToZero(); // this isn't strictly needed but it will throw maybe-unitinlised warnings if disabled
				enableSsoFlag();
				if constexpr (isNullTerminatedPod())
					d.sso[0] = 0;
				}
			
			// Asserts:
			// sso must be bigger than the storage struct otherise ssoSize will alias
			static_assert(sizeof(storage) <= N); // warning: if sizeof(storage) == N then capacity may alias into sso.size
			
			// Local storage is must fit into a SSO_SIZE_T with the high bit set to low
			static_assert(N <= (1 << (sizeof(SSO_SIZE_T)*8 - 1)));
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::~ sso_base ()
                            {
			#if STT_STL_DEBUG
				#if STT_STL_DEBUG > 1
					printf("deconstruct sso_base: %p %s\n", this, __PRETTY_FUNCTION__);
				#endif
			#endif
			destroy_elements();
			if (!useSso())
				d.store.deallocate();
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::dbg_printf () const
                                         {
			#if STT_STL_DEBUG
				char buff[1024];
				dbg_snprintf(buff, 1023);
				printf("%s", buff);
				if (!useSso())
					d.store.dbg_printf();
			#endif
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::dbg_snprintf (char * buff, uint64_t sz) const
                                                                  {
			#if STT_STL_DEBUG
				snprintf(buff, sz, "sso_base<%i>: isPod: %b, useSso: %b, sso_size %i, sso_size_bits %s, store_capacity_bits %s, sso_capacity %i, data(): %lx, size(): %i, capacity(): %i \n",
					element_size(), isPod(), useSso(), local_size(), std::bitset<sizeof(SSO_SIZE_T)*8>(local_size_ref_c()).to_string().c_str(), std::bitset<sizeof(storage_size_t)*8>(d.store.capacity).to_string().c_str(), local_capcity(), (intptr_t) data(), size(), capacity());
			#endif
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::dbg_dump_row () const
                                           {
			#if STT_STL_DEBUG
			storage_size_t sz = size()/sizeof(int);
			int* _data = (int*) data();
			for (storage_size_t i = 0; i < sz; ++i) {
				printf("%i ", _data[i]);
				}
			#endif
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::dbg_dump () const
                                       {
			#if STT_STL_DEBUG
			storage_size_t sz = size()/sizeof(int);
			int* _data = (int*) data();
			for (storage_size_t i = 0; i < sz; ++i) {
				printf("\t%i: %i\n", i, _data[i]);
				}
			#endif
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr bool sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::isPod ()
                                                          { return std::is_same<T, sso_pod_tag>::value || std::is_same<T, sso_null_terminated_pod_tag>::value; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr bool sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::isNullTerminatedPod ()
                                                                        { return std::is_same<T, sso_null_terminated_pod_tag>::value; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr storage_size_t sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::null_termination_padding ()
                                                                                       { if constexpr (isNullTerminatedPod()) return 1; return 0; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr storage_size_t sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::max_size ()
                                                                       { return ~(1 << (sizeof(SSO_SIZE_T)*8-1)); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr storage_size_t sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::element_size ()
                                                                           { return isPod() ? 1 : sizeof(T); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr SSO_SIZE_T sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::local_capcity ()
                                                                        { return N-sizeof(SSO_SIZE_T)-null_termination_padding(); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr bool sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::isAlwaysStore ()
                                                                  { return IS_ALWAYS_STORE; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr SSO_SIZE_T & sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::local_size_ref ()
                                                                   { return *((SSO_SIZE_T*) &d.sso[N-sizeof(SSO_SIZE_T)]); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr SSO_SIZE_T const & sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::local_size_ref_c () const
                                                                                 { return *((SSO_SIZE_T*) &d.sso[N-sizeof(SSO_SIZE_T)]); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE constexpr SSO_SIZE_T sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::sso_size_flag () const
                                                                       { return (1 << (sizeof(SSO_SIZE_T)*8-1)); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::enableSsoFlag ()
                                             { local_size_ref() = sso_size_flag(); }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::disableSsoFlag ()
                                             {
			// ! This can override store.capacity!
			if constexpr (N > sizeof(storage))
				d.sso[N-1] = 0;
			else
				local_size_ref() = 0;
				}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE SSO_SIZE_T sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::local_size () const
                                                     {
			// Returns currently used sso size (in bytes)
			return local_size_ref_c() & ~sso_size_flag();
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::set_local_size (storage_size_t const sz)
                                                                    {
			#if STT_STL_DEBUG
			if constexpr(isAlwaysStore()) {
				STT_STL_ASSERT(false, "set_local_size while isAlwaysStore true");
				}
			#endif
			local_size_ref() = sz | sso_size_flag();																		
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE bool sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::useSso () const
                                           {
			// Returns if we are using sso (true) or storage (false)
			if constexpr(isAlwaysStore())
				return false;
			if constexpr (N > sizeof(storage))
				return d.sso[N-1];
			return d.sso[N-1] & (1 << 7);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE uint8_t * sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::data ()
                                       { return useSso() ? &d.sso[0] : d.store.ptr; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE uint8_t const * sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::data () const
                                                   { return useSso() ? &d.sso[0] : d.store.ptr; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE storage_size_t sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::size () const
                                                   { return useSso() ? local_size() : d.store.size; }
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE storage_size_t sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::capacity () const
                                                       {
			return useSso() ? local_capcity() : (d.store.capacity - null_termination_padding());
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::switchToStorage ()
                                              {
			if (useSso())
				switchToStorage_impl(local_size(), NULL);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::setAllocator (allocatorI * alloc)
                                                     {
			if (useSso()) {
				switchToStorage_impl(local_size(), alloc);
				d.store.mAllocator = alloc;
				}
			else {
				STT_STL_ASSERT(d.store.ptr == NULL, "setting an allocator when non-sso data is already allocated is undefined behaviour");
				d.store.mAllocator = alloc;
				}
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::switchToStorage_impl (storage_size_t const wantsCapacityBytes, allocatorI * mAllocator)
                                                                                                            {
			storage store2;
			store2.initToZero();
			store2.mAllocator = mAllocator;
			const storage_size_t ck = storage::calcualteNextCapacity(mAllocator, N-1, wantsCapacityBytes + null_termination_padding(), element_size());
			store2.growCapacity(ck, (T*) NULL);
					
			//printf("move elements %lx, %lx, %i:\n", (intptr_t) store2.ptr, (intptr_t) &d.sso[0], local_size()/element_size());
			move_elements_in_place(store2.ptr, &d.sso[0], local_size()/element_size());
			store2.size = local_size();
			
			d.store = store2;
			disableSsoFlag();
			
			//d.store.dbg_printf();
			//dbg_dump();
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::switchToSso_impl ()
                                        {
			// switching without checking capacity first is UB
			#if STT_STL_DEBUG
			STT_STL_ASSERT(d.store.mAllocator == 0, "allocator null check"); // do not deallocate if not null
			STT_STL_ASSERT(!isAlwaysStore(), "always store check"); // do not deallocate if not null
			#endif
			storage store2 = d.store;
			move_elements_in_place(&d.sso[0], store2.ptr, store2.size/element_size());
			set_local_size(store2.size);
			store2.deallocate();
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE uint8_t * sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::reserve_impl_sso (storage_size_t const wantCapacityBytes, storage_size_t const incrSize)
                                                                                                                            {
			// reserves and moves current size by incrSize bytes. returns the address before incrementing
			if (wantCapacityBytes <= local_capcity()) {
				const storage_size_t ls = local_size();
				uint8_t* r = &d.sso[ls];
				set_local_size(ls + incrSize);
				return r;
				}
			else {
				switchToStorage_impl(wantCapacityBytes, NULL);
				uint8_t* r = &d.store.ptr[d.store.size];
				d.store.size += incrSize;
				return r;
				}
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE uint8_t * sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::reserve_impl_store (storage_size_t const wantCapacityBytes, storage_size_t const incrSize)
                                                                                                                              {
			const storage_size_t origCapacity = d.store.capacity;
			if (wantCapacityBytes >= origCapacity) {
				const storage_size_t ck = storage::calcualteNextCapacity(d.store.mAllocator, origCapacity, wantCapacityBytes + null_termination_padding(), element_size());
				d.store.growCapacity(ck, (T*) NULL);
				}
				
			uint8_t* r = &d.store.ptr[d.store.size];
			d.store.size += incrSize;
			return r;
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  uint8_t * sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::reserve (storage_size_t const wantCapacityBytes, storage_size_t const incrSize)
                                                                                                            {
			// if incrSize is non-zero then also update the size as well as the capacity
			// Returns the end of the current data pointer (before updating size)
			// *does not initialise reserved memory*
			if (useSso())
				return reserve_impl_sso(wantCapacityBytes, incrSize);
			else
				return reserve_impl_store(wantCapacityBytes, incrSize);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::resize (uint32_t const sizeInBytes)
                                                        {
			// note that true capacity 
			// standard coding convention is that resize(0) should clear and deallocate a buffer
			if (sizeInBytes == 0)
				return clearAndDeallocate();
			resize_impl(sizeInBytes);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::resize_impl (uint32_t const sizeInBytes, bool const tfill)
                                                                                      {
			// resizes and does not call destructors
			//printf("resize impl %i\n", sizeInBytes);
			
			if (sizeInBytes > capacity())
				reserve(sizeInBytes, 0);
			
			constexpr bool doFill = true;//stt::requires_fill_on_resize<T>::value;
			
			if (useSso()) {
				const storage_size_t oldSize = doFill ? local_size() : 0;
				
				if (sizeInBytes <= local_capcity()) {
					set_local_size(sizeInBytes);
					
					if constexpr (doFill)
						if (tfill)
							fill_or_destroy_elements(&d.sso[oldSize], oldSize, sizeInBytes);
					}
				else {
					switchToStorage_impl(sizeInBytes, NULL);
					
					if constexpr (doFill)
						if (tfill)
							fill_or_destroy_elements(&d.store.ptr[oldSize], oldSize, sizeInBytes);
					}
				}
			else {
				if constexpr (doFill)
					if (tfill)
						fill_or_destroy_elements(&d.store.ptr[d.store.size], d.store.size, sizeInBytes);
							
				d.store.size = sizeInBytes;
				}
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::fill_or_destroy_elements (uint8_t * dst, storage_size_t const oldSize, storage_size_t const newSize)
                                                                                                                        {
			// Dst = data()[oldSize]
			// oldsize/newsize is in bytes
			if constexpr (isPod()) {
				if (newSize > oldSize) {
					// zero fill
					stt_memset(dst, 0, (newSize - oldSize));
					}
				return;
				}
			if (newSize > oldSize) {
				fill_elements_in_place(dst, (newSize - oldSize)/element_size());
				}
			else if (oldSize > newSize) {
				const storage_size_t count = (oldSize - newSize)/element_size();
				T* start = (T*) dst - count;
				T* end = (T*) dst;
				for (T* ptr = start ; ptr != end; ++ptr )
					ptr->~T();
				}
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::copy_elements (uint8_t * dst, uint8_t const * src, storage_size_t const num_elements_or_bytes)
                                                                                                                 {
			// note: if this is pod you need to pass *bytes* not num_elements
			if constexpr (isPod())
				stt_memcpy(dst, src, num_elements_or_bytes);
			else
				objectCopyRange((T*) dst, (const T*) src, ((const T*) src) + num_elements_or_bytes);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::copy_elements_in_place (uint8_t * dst, uint8_t const * src, storage_size_t const num_elements_or_bytes)
                                                                                                                          {
			// will override objects
			if constexpr (isPod())
				stt_memcpy(dst, src, num_elements_or_bytes);
			else
				objectCopyRangeInPlace((T*) dst, (const T*) src, ((const T*) src) + num_elements_or_bytes);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::move_elements_in_place (uint8_t * dst, uint8_t * src, storage_size_t const num_elements_or_bytes)
                                                                                                                    {
			// use if dst is unintialised memory. Assigns dst with `new(dst[i]) T(std::move(src[i]))`
			if constexpr (isPod())
				stt_memcpy(dst, src, num_elements_or_bytes);
			else 
				objectMoveRangeInPlace((T*) dst, (T*) src, ((T*) src) + num_elements_or_bytes);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::fill_elements_in_place (uint8_t * dst, storage_size_t const num_elements_or_bytes)
                                                                                                      {
			if constexpr (isPod())
				stt_memset(dst, 0, num_elements_or_bytes);
			else 
				objectFillRangeInPlace((T*) dst, ((T*) dst) + num_elements_or_bytes);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  LZZ_INLINE void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::destroy_elements ()
                                               {
			// Only generate function destroy_elements_impl() if not pod
			if constexpr (!isPod())
				destroy_elements_impl();
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::destroy_elements_impl ()
                                             {
			if constexpr (!isPod()) {
				T* tptr = (T*) data();
				const storage_size_t _size = size() / element_size();
				for (storage_size_t i = 0; i < _size; ++i)
					tptr[i].~T();
				}
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::clear ()
                             {
			// marks buffer as empty
			destroy_elements();
			
			if (useSso())
				set_local_size(0);
			else
				d.store.size = 0;
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::clearAndDeallocate ()
                                          {
			// marks buffer as empty
			destroy_elements();
			
			if (!useSso()) {
				d.store.deallocate();
				if (d.store.mAllocator) {
					d.store.size = 0;
					d.store.capacity = 0;
					return;
					}
				if (isAlwaysStore())
					return; // return to prevent falling though and switching to Store
				}
			set_local_size(0);
			}
}
namespace stt
{
  template <unsigned int N, typename T, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
  void sso_base <N, T, SSO_SIZE_T, IS_ALWAYS_STORE>::shrink_to_fit ()
                                     {
			if (useSso()) return; // sso - cannot be shrunk
			if (d.store.size <= local_capcity() && !isAlwaysStore()) {
				// switch back to sso
				if (d.store.mAllocator)
					d.store.shrink_to_fit((T*) NULL);
				else
					switchToSso_impl();
				}
			else {
				// realloc and shrink
				d.store.shrink_to_fit((T*) NULL);
				}
			}
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_sso
#define STT_STL_IMPL_DOUBLE_GUARD_sso
#define LZZ_OVERRIDE
// sso.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_sso
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// page.hh
//

#ifndef LZZ_page_hh
#define LZZ_page_hh
#ifndef STT_PAGE_HEADER_SIZE
	#define STT_PAGE_HEADER_SIZE 64
#endif
#ifndef STT_PAGE_SIZE
	#define STT_PAGE_SIZE 4080	// this makes alignement better 
#endif
#ifndef STT_JUMBO_PAGE_SIZE
	#define STT_JUMBO_PAGE_SIZE 65520
#endif

	
#define LZZ_INLINE inline
namespace stt
{
  enum pageTypeEnum
  {
    PAGE_TYPE_NORMAL,
    PAGE_TYPE_JUMBO,
    PAGE_TYPE_UNSET
  };
}
namespace stt
{
  char const * pageTypeEnumToString (pageTypeEnum const pt);
}
namespace stt
{
  struct pageHeader
  {
    pageHeader * next;
    pageHeader * cachedWorkingEnd;
    uint64_t allocationInfo;
    uint32_t localSize;
    uint32_t totalSize;
    uint64_t (userData) [4];
    void initToZero ();
    void appendList (pageHeader * other);
    pageHeader * splitList (uint32_t const nPages);
    static pageHeader * buildList (pageHeader * * pages, uint32_t const nPages);
    pageHeader * end ();
    pageHeader * endCounting (int & countOut);
    pageHeader * endCountingDumping (int & countOut);
    int listLength ();
    uint8_t * toPayload ();
    static pageHeader * fromPayload (uint8_t * ptr);
  };
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  union pageTemplate
  {
    pageHeader ph;
    uint8_t (_data) [SIZE];
    void initHeader ();
    constexpr uint8_t * ptr ();
    constexpr uint8_t const * ptr () const;
    static constexpr size_t capacity ();
    static constexpr size_t storageSize ();
    static constexpr pageTypeEnum getPageType ();
  };
}
namespace stt
{
  typedef pageTemplate <STT_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_NORMAL> pageU;
}
namespace stt
{
  typedef pageTemplate <STT_JUMBO_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_JUMBO> jumboPageU;
}
namespace stt
{
  LZZ_INLINE void pageHeader::initToZero ()
                                         {
			//allocator = NULL;
			next = NULL;
			cachedWorkingEnd = NULL;
			allocationInfo = 0;
			localSize = 0;
			totalSize = 0;
			userData[0] = 0;
			userData[1] = 0;
			userData[2] = 0;
			userData[3] = 0;
			}
}
namespace stt
{
  LZZ_INLINE uint8_t * pageHeader::toPayload ()
                                            {
			uint8_t* ptr = (uint8_t*) this;
			return &ptr[STT_PAGE_HEADER_SIZE];
			}
}
namespace stt
{
  LZZ_INLINE pageHeader * pageHeader::fromPayload (uint8_t * ptr)
                                                                    {
			// Reverse operation of pageU::ptr(), takes a page's data pointer and returns the address of the header
			return (pageHeader*) &ptr[-STT_PAGE_HEADER_SIZE];
			}
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  LZZ_INLINE void pageTemplate <SIZE, ET>::initHeader ()
                                         { ph.initToZero(); ph.allocationInfo = SIZE; }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr uint8_t * pageTemplate <SIZE, ET>::ptr ()
                                                          { return &_data[STT_PAGE_HEADER_SIZE]; }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr uint8_t const * pageTemplate <SIZE, ET>::ptr () const
                                                          { return &_data[STT_PAGE_HEADER_SIZE]; }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr size_t pageTemplate <SIZE, ET>::capacity ()
                                                        { return SIZE - STT_PAGE_HEADER_SIZE;  }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr size_t pageTemplate <SIZE, ET>::storageSize ()
                                                           { return SIZE;  }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr pageTypeEnum pageTemplate <SIZE, ET>::getPageType ()
                                                                 { return ET; }
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_page
#define STT_STL_IMPL_DOUBLE_GUARD_page
#define LZZ_OVERRIDE
// page.cpp
//


namespace stt {
	static_assert(sizeof(pageHeader) <= STT_PAGE_HEADER_SIZE);
	}
#define LZZ_INLINE inline
namespace stt
{
  char const * pageTypeEnumToString (pageTypeEnum const pt)
                                                                 {
		switch (pt) {
			case pageTypeEnum::PAGE_TYPE_NORMAL: return "Normal";
			case pageTypeEnum::PAGE_TYPE_JUMBO: return "Jumbo";
			default: return "Unset";
			}
		}
}
namespace stt
{
  void pageHeader::appendList (pageHeader * other)
                                                   {
			// appends other to this list
			// assumes cachedWorkingEnd is a valid value for both this and othe
			// assumes other is not null
			cachedWorkingEnd->next = other;
			cachedWorkingEnd = other->cachedWorkingEnd;
			}
}
namespace stt
{
  pageHeader * pageHeader::splitList (uint32_t const nPages)
                                                             {
			// assumes cachedWorkingEnd is a valid value for this
			// if this is too short then returns NULL
			pageHeader* w = this;
			uint32_t cnt = 1;
			while (w->next && (cnt < nPages)) {
				cnt++;
				w = w->next;
				}
			// w should now be the end of this list
			// and w->next should be the start of next
			if (!w) return NULL; // fail split
			if (!w->next) return NULL; // fail split
			
			pageHeader* r = w->next;
			r->cachedWorkingEnd = cachedWorkingEnd;
			w->next = NULL;
			cachedWorkingEnd = w;
			return r;
			}
}
namespace stt
{
  pageHeader * pageHeader::buildList (pageHeader * * pages, uint32_t const nPages)
                                                                                        {
			// assembles pages into a linked list, returns the head
			if (!nPages) return NULL;
			for (uint32_t i = 0; i < nPages-1; ++i) {
				pages[i]->next = pages[i+1];
				}
			pages[nPages-1]->next = NULL;
			pages[0]->cachedWorkingEnd = pages[nPages-1];
			return pages[0];
			}
}
namespace stt
{
  pageHeader * pageHeader::end ()
                                  {
			// manually traverses to the end
			pageHeader* w = this;
			while (w->next) { w = w->next; }
			return w;
			}
}
namespace stt
{
  pageHeader * pageHeader::endCounting (int & countOut)
                                                       {
			// manually traverses to the end, counts number of pages
			pageHeader* w = this;
			countOut++;
			while (w->next) { w = w->next; countOut++; }
			return w;
			}
}
namespace stt
{
  pageHeader * pageHeader::endCountingDumping (int & countOut)
                                                              {
			pageHeader* w = this;
			countOut++;
			while (w->next) {
				w = w->next;
				#ifdef STT_STL_DEBUG
				stt_dbg_log("\t\tendCountingDumping %p %i deep is %p\n", this, countOut, w);
				#endif
				countOut++; 
				}
			return w;
			}
}
namespace stt
{
  int pageHeader::listLength ()
                                 {
			int cnt = 0;
			endCounting(cnt);
			return cnt;
			}
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_page
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// varray.hh
//

#ifndef LZZ_varray_hh
#define LZZ_varray_hh

namespace stt {
	class allocatorI;
	}
#define LZZ_INLINE inline
namespace stt
{
  template <typename T, uint32_t stackCapacity>
  class varray
  {
  public:
    uint8_t (buff) [stackCapacity*sizeof(T)];
    T * data;
    allocatorI * alloc;
    uint32_t size;
    varray (uint32_t const _size, allocatorI * _alloc = NULL);
    ~ varray ();
    T & operator [] (uint32_t const idx);
    T const & operator [] (uint32_t const idx) const;
  };
}
namespace stt
{
  template <typename T, uint32_t stackCapacity>
  varray <T, stackCapacity>::varray (uint32_t const _size, allocatorI * _alloc)
                                                                {
		if STT_STL_LIKLEY(_size <= stackCapacity) {
			data = (T*) &buff[0];
			alloc = NULL;
			size = _size;
			}
		else {
			const alloc_size_t wantsSize = _size*sizeof(T);
			alloc = _alloc;
			if (!alloc)
				alloc = crt_allocator::getStaticCrtAllocator();
			data = (T*) alloc->allocate(wantsSize);
			size = _size;
			}
		if constexpr (requires_fill_on_resize<T>::value) {
			objectFillRangeInPlace<T>(&data[0], &data[size]);
			}
		}
}
namespace stt
{
  template <typename T, uint32_t stackCapacity>
  varray <T, stackCapacity>::~ varray ()
                  {
		if constexpr (requires_destroy_on_resize<T>::value) {
			objectDestroyRange<T>(&data[0], &data[size]);
			}
		if (alloc)
			alloc->deallocate((uint8_t*) data, size*sizeof(T));
		}
}
namespace stt
{
  template <typename T, uint32_t stackCapacity>
  LZZ_INLINE T & varray <T, stackCapacity>::operator [] (uint32_t const idx)
                                                   { return data[idx]; }
}
namespace stt
{
  template <typename T, uint32_t stackCapacity>
  LZZ_INLINE T const & varray <T, stackCapacity>::operator [] (uint32_t const idx) const
                                                               { return data[idx]; }
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_varray
#define STT_STL_IMPL_DOUBLE_GUARD_varray
#define LZZ_OVERRIDE
// varray.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_varray
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// vector.hh
//

#ifndef LZZ_vector_hh
#define LZZ_vector_hh
//#include <iterator>


namespace stt {	
	template<typename V, typename T, unsigned int N>
	struct vector_ref_impl;

	template <typename T, typename TPOD, unsigned int N, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
	class vector_base_traits;
	
	template<unsigned int A, unsigned int B>
	struct always_store_test {
		static constexpr bool value = A >= B ? true : false;
		};
	
	template <typename T, unsigned int N>
	using vector_base_wrap = vector_base_traits<T, pod_proxy<T>, N, uint8_t, always_store_test<sizeof(T),N-sizeof(uint8_t)>::value>;
	
	// Note that we have to extend the class to prevent container-depending-on-incomplete-class issues
	template <typename T, unsigned int N> 
	class vector_base : public vector_base_wrap<T,N> {
		public:
		using unwrapped_type = vector_base_wrap<T,N>;
		using vector_base_wrap<T,N>::vector_base_wrap;
		};
	
	// Alternative vector_base for incomplete types
	// you need to manually specify canUseSso and isPod
	// can automatically be cast to vector_base<T,N>
	// will throw static_assert if this is not the same as vector_base<T,N>
	template <typename T, unsigned int N, bool canUseSso, bool isPod> 
	using vector_base_forward_compatable_base = vector_base_traits<T,typename std::conditional<isPod, sso_pod_tag, T>::type,N,uint8_t,!canUseSso>;
	
	template <typename T, unsigned int N, bool canUseSso, bool isPod> 
	class vector_base_forward_compatable : public vector_base_forward_compatable_base<T,N,canUseSso,isPod> {
		public:
		using unwrapped_type = vector_base_forward_compatable_base<T,N,canUseSso,isPod>;
		using unwrapped_type::unwrapped_type;
		inline vector_base<T,N>& v() {
			static_assert(is_same<unwrapped_type, typename vector_base<T,N>::unwrapped_type>::value);
			return *((vector_base<T,N>*) this);
			};
		inline const vector_base<T,N>& v() const {
			static_assert(is_same<unwrapped_type, typename vector_base<T,N>::unwrapped_type>::value);
			return *((vector_base<T,N>*) this);
			};
		inline vector_base<T,N>& operator() () { return v(); }
		inline const vector_base<T,N>& operator() () const { return v(); }
		};
		
	template <typename T>
	using vector24 = vector_base<T, 24>;
	template <typename T>
	using vector32 = vector_base<T, 32>;
	template <typename T>
	using vector64 = vector_base<T, 64>;
	
	template <typename T, bool canUseSso, bool isPod>
	using vector_forward24 = vector_base_forward_compatable<T, 24, canUseSso, isPod>;
	
			
	// small_vector - a vector of sso_size of at least NUM_ELEMENTS
	template <typename T, unsigned int NUM_ELEMENTS, typename SSO_SIZE_T = uint8_t>
	class small_vector : public vector_base_traits<T, pod_proxy<T>, sizeof(T)*NUM_ELEMENTS + sizeof(SSO_SIZE_T), SSO_SIZE_T, false> {};
	
	template <typename T, typename TPOD, unsigned int N, typename SSO_SIZE_T, bool IS_ALWAYS_STORE>
	class vector_base_traits {
	public:
		using iterator       = T*;
		using const_iterator = const T*;
		using size_type = storage_size_t;
		using reference      = T&;
		using const_reference = const T&;
		using reverse_iterator = stt::reverse_iterator<iterator>;
		using const_reverse_iterator = stt::reverse_iterator<const_iterator>;
		typedef T value_type;
	
		sso_base<N, TPOD, SSO_SIZE_T, IS_ALWAYS_STORE> sso; //<-- sso should just have reserve and give the write ptr

		// String compatability stuff
		inline static constexpr bool isString() { return stt::is_same<TPOD, sso_null_terminated_pod_tag>::value; }
		inline static constexpr bool isPod() { return stt::is_same<TPOD, sso_null_terminated_pod_tag>::value || stt::is_same<TPOD, sso_pod_tag>::value; }
		inline static constexpr bool isAlwaysStore() { return IS_ALWAYS_STORE; }
		
		inline void writeNullTerminator(uint8_t* ptr) { if constexpr (isString()) { *ptr = 0; }; }

		// casting
		//inline vector_ref_impl<vector_base_traits,T,N>& operator ()             { return *((vector_proxy<T,N>*) this); }
		//inline const vector_ref_impl<vector_base_traits,T,N>& operator () const { return *((vector_proxy<T,N>*) this); }

		// constructor
		inline vector_base_traits() {}
		inline ~vector_base_traits() {}
		
		inline vector_base_traits(allocatorI * alloc) {
			sso.init();
			sso.setAllocator(alloc);
			}
			
		inline vector_base_traits(const vector_base_traits & other) {
			sso.init();
			*this = other;
			}
		
		inline vector_base_traits(vector_base_traits&& other) {
			sso.init();
			*this = std::move(other);
			}
			
		inline vector_base_traits(const storage_size_t sz) {
			sso.init();
			batch_append_fill(sz);
			}
			
		inline vector_base_traits(const T* first, const T* last) {
			sso.init();
			batch_append_copy(first, last - first);
			}
			
		template<typename Iter>
		inline vector_base_traits(stt::move_iterator<Iter> first, stt::move_iterator<Iter> last) {
			sso.init();
			batch_append_move(first.base(), last - first);
			}
			
		inline vector_base_traits(const storage_size_t sz, const T & value) {
			sso.init();
			batch_append_fill_value(value, sz);
			}
		
		inline vector_base_traits (initializer_list<T> li) {
			sso.init();
			batch_append_copy(li.begin(), li.size());
			}
		
		vector_base_traits (allocatorI* dataAllocator, const T* const data, const storage_size_t size) {
			sso.init();
			sso.setAllocator(dataAllocator);
			batch_append_copy(data, data+size);
			}
		
		inline void markInterned() {
			// Marks this data as "interned", as in not owned by the container.
			// Any realloc will fire an assert
			// Any dealloc will be a noop 
			STT_STL_ASSERT(!sso.useSso(), "cannot intern a container that is not using a custom allocator");
			sso.d.store.mAllocator = &stt::null_view_allocator::m_static_null_view_allocator;
			}
		
		inline bool isInterned () const {
			return (sso.d.store.mAllocator == &stt::null_view_allocator::m_static_null_view_allocator);
			}
		
		//template<typename V>
		//vector_base_traits (initializer_list<V> li) {
		//	sso.init();
		//	if (!li.size()) return;
		//	reserve(li.size());
		//	auto itt = li.begin();
		//	for (;itt != li.end(); itt++)
		//		push_back(T(*itt));
		//	}
		
		vector_base_traits& operator = (const vector_base_traits & other) {
			//printf("copy construct\n");
			sso.clear();
			batch_append_copy(other.data(), other.size());
			return *this;
			}
		
		vector_base_traits& operator = (vector_base_traits&& other) {
			//printf("move construct\n");
			allocatorI* a = other.getCustomAllocator();
			if ((!other.sso.useSso()) && (a || other.sso.size() > sso.capacity())) {
				// Other is using store, just move store variable
				sso.clearAndDeallocate();
				sso.disableSsoFlag();
				sso.d.store = other.sso.d.store;
				other.sso.init(); // reset to an empty container without calling destructors
				return *this;
				}
			sso.clear();
			batch_append_move(other.data(), other.size()); // call std::move on all elements and leave other alone
			return *this;
			}
			
			

		void assign (const T* first, const T* last) {
			sso.clear();
			batch_append_copy(first, last - first);
			}
			
		void assign (const storage_size_t sz, const T &  value) {
			sso.clear();
			batch_append_fill_value(value, sz);
			}
			
		void shrink_to_fit() { sso.shrink_to_fit(); }
		
		inline span<T> to_span () const noexcept { return span<T>(data(), size()); }
		
		inline void setAllocator(allocatorI * alloc) { sso.setAllocator(alloc); }
		inline allocatorI* getCustomAllocator() const { return (sso.useSso() ? NULL : sso.d.store.mAllocator); } // returns the custom allocator object, if set. If no custom allocator has been set return NULL
		
		inline T& at	   (const storage_size_t idx) noexcept       { if (idx >= size()) { stt::error::array_out_of_bounds(idx, size()); }; return *this[idx]; }
		inline const T& at (const storage_size_t idx) const noexcept { if (idx >= size()) { stt::error::array_out_of_bounds(idx, size()); }; return *this[idx]; }
		
		inline T& operator []       (const storage_size_t idx) noexcept       { return data()[idx]; }
		inline const T& operator [] (const storage_size_t idx) const noexcept { return data()[idx]; }
		
		inline T* data() noexcept             { return (T*) sso.data(); }
		inline const T* data() const noexcept { return (const T*) sso.data(); }
		inline storage_size_t size() const noexcept     { return sso.size()/sizeof(T); }
		inline uint64_t size_bytes() const noexcept     { return sso.size(); }
		inline storage_size_t length() const noexcept   { return sso.size()/sizeof(T); }
		inline storage_size_t capacity() const noexcept { return sso.capacity()/sizeof(T); }
		inline static constexpr storage_size_t max_size() { return decltype(sso)::max_size(); }
		
		inline const_iterator cbegin() const noexcept { return const_iterator(data()); }
		inline const_iterator cend()   const noexcept { return const_iterator(data() + size()); };
		inline const_iterator begin() const noexcept { return const_iterator(data()); }
		inline const_iterator end()   const noexcept { return const_iterator(data() + size()); };
		inline iterator begin() noexcept { return iterator(data()); }
		inline iterator end()   noexcept { return iterator(data() + size()); }
		
		inline reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
		inline reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
		inline const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }
		inline const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }
		inline const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
		inline const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }
		
		inline bool empty() const { return !sso.size(); }
		
		inline T& front()             { return data()[0]; }
		inline const T& front() const { return data()[0]; }
		inline T& back()             { return data()[size()-1]; }
		inline const T& back() const { return data()[size()-1]; }
		
		inline void clear() {
			sso.clear();
			if constexpr (isString())
				writeNullTerminator((uint8_t*) sso.data());
			}
		
		inline bool isUsingSso()  const { return sso.useSso(); }
		inline bool isUsingHeap() const { return !sso.useSso(); }
		
		void push_back(const T& t) {
			constexpr storage_size_t stride = sizeof(T);
			uint8_t* ptr = sso.reserve(sso.size() + stride, stride);
			
			new (ptr) T(t); // copy construct in place
			//*((T*) ptr) = t;
			
			writeNullTerminator(ptr+1);
			}
			
		void push_back(T&& t) {
			constexpr storage_size_t stride = sizeof(T);
			uint8_t* ptr = sso.reserve(sso.size() + stride, stride);
			
			new (ptr) T(std::move(t)); // move construct in place
			//*((T*) ptr) = std::move(t);
			
			writeNullTerminator(ptr+1);
			}
			
		void pop_back() {
			const storage_size_t sz = size();
			if (sz)
				resize(sz-1);
			}
			
		void discard_internal_state() {
			// Discards any internal state and resets to a blank container
			// Does not call destructors, deallocate or do any cleanup.
			//
			// Use this if a custom allocator owns the underlying memory
			// and this memory becomes invalid
			sso.d.store.initToZero();
			sso.init();
			}

//protected:
public:
// These are normally internal only functions but are useful
		void batch_append_copy(const T* begin, const storage_size_t count) {
			constexpr storage_size_t stride = sizeof(T)/(decltype(sso)::element_size());
			
			uint8_t* ptr = sso.reserve(sso.size() + sizeof(T)*count, sizeof(T)*count);
			sso.copy_elements_in_place(ptr, (const uint8_t*) begin, count*stride);
			if constexpr (isString()) writeNullTerminator(ptr + count);
			}
			
		void batch_append_move(T* begin, const storage_size_t count) {
			constexpr storage_size_t stride = sizeof(T)/(decltype(sso)::element_size());
			
			uint8_t* ptr = sso.reserve(sso.size() + sizeof(T)*count, sizeof(T)*count);
			sso.move_elements_in_place(ptr, (uint8_t*) begin, count*stride);
			if constexpr (isString()) writeNullTerminator(ptr + count);
			}
			
		void batch_append_fill_value(const T & value, const storage_size_t count) {
			uint8_t* ptr = sso.reserve(sso.size() + sizeof(T)*count, sizeof(T)*count);
			objectFillRangeValueInPlace((T*) ptr, ((T*) ptr) + count, value);
			if constexpr (isString()) writeNullTerminator(ptr + count);
			}
			
		void batch_append_fill(const storage_size_t count) {
			constexpr storage_size_t stride = sizeof(T)/(decltype(sso)::element_size());
			
			uint8_t* ptr = sso.reserve(sso.size() + sizeof(T)*count, sizeof(T)*count);
			sso.fill_elements_in_place(ptr, count*stride);
			if constexpr (isString()) writeNullTerminator(ptr + count);
			}

public:
		void reserve(const storage_size_t sz) {
			sso.reserve(sizeof(T) * sz);
			}
			
		void resize(const storage_size_t sz) {			
			sso.resize(sz*sizeof(T));
			
			if constexpr (isString()) writeNullTerminator((uint8_t*) end());
			}
			
		void resize_no_zero_initialise(const storage_size_t sz) {
			// I hope you know what you're doing, do not do this with objects
			sso.resize_impl(sz*sizeof(T), false);
			}
			
		void resize(const storage_size_t sz, const T&value) {
			// resize and fill with value if new size is bigger
			storage_size_t sz_init = size();
			if (sz > sz_init) {
				uint8_t* ptr = sso.reserve(sizeof(T) * sz, (sz - sz_init)*sizeof(T));
				objectFillRangeValueInPlace((T*) ptr, ((T*) ptr) + (sz - sz_init), value);
				}
			else
				sso.resize(sizeof(T)*sz);
				
			if constexpr (isString()) writeNullTerminator((uint8_t*) end());
			}
			
		void swap_allocator_pointers(vector_base_traits & other) {
			// I hope you know what you're doing with this
			// only call if the allocator objects are swapping their internal arenas
			if (!isUsingHeap()) STT_STL_ABORT();
			if (!other.isUsingHeap()) STT_STL_ABORT();
			allocatorI* tmp = sso.d.store.mAllocator;
			sso.d.store.mAllocator = other.sso.d.store.mAllocator;
			other.sso.d.store.mAllocator = tmp;
			}
			
		void swap(vector_base_traits & other) {
			if constexpr (IS_ALWAYS_STORE) {
				return swap_heap_impl(other);
				}
			
			if (isUsingHeap()) {
				if (other.isUsingHeap()) {
					//printf("swap path A\n");
					// both are using heap, so straight swap of storage data
					swap_heap_impl(other);
					}
				else {
					//printf("swap path B\n");
					// execute the below branch with the arguments reversed
					other.swap2_impl(*this);
					}
				}
			else {
				//printf("swap path C\n");
				swap2_impl(other);
				}
			}

protected:
		inline void swap_heap_impl(vector_base_traits & other) {
			storage stemp = sso.d.store;
			sso.d.store = other.sso.d.store;
			other.sso.d.store = stemp;
			}
		
		void swap2_impl (vector_base_traits & other) {
			// call swap(), not this
			constexpr storage_size_t stride = (decltype(sso)::element_size());
					
			// move this's sso data to a temp buffer
			const storage_size_t lsz = sso.local_size();
			uint8_t tmpBuff[sizeof(*this)];
			sso.move_elements_in_place(&tmpBuff[0], &sso.d.sso[0], lsz / stride); // we are copying into unitialised space so we must in-place move
			
			//printf("swap2_impl %s\n", __PRETTY_FUNCTION__);
			//printf("swap2_impl lsz %i, stride %i\n", lsz, stride);
				
			// override this with other
			if (other.isUsingHeap()) {
				// other is using heap, copy sso to temp. buffer
				//printf("swap2_impl path A\n");
				sso.d.store = other.sso.d.store;
				sso.disableSsoFlag();
				}
			else {
				//printf("swap2_impl path B\n");
				const storage_size_t olsz = other.sso.local_size();
				sso.move_elements_in_place(&sso.d.sso[0], &other.sso.d.sso[0], olsz / stride);
				sso.set_local_size(olsz);
				if constexpr (isString()) writeNullTerminator(&sso.d.sso[olsz]);
				}
				
			// put the temp sso data into temp and switch it to sso mode
			other.sso.move_elements_in_place(&other.sso.d.sso[0], &tmpBuff[0], lsz / stride);
			other.sso.set_local_size(lsz);
			if constexpr (isString()) other.writeNullTerminator(&other.sso.d.sso[lsz]);
			}
		
public:
		iterator erase (iterator where) {
			// move then call destructor
			if constexpr (isPod()) {
				// if pod then just memmove
				// if not last element then shift back
				iterator iend = end();
				if (where < end() - 1)
					stt_memmove((uint8_t*) where, (uint8_t*) (where+1), (iend - where)*sizeof(T));
				
				sso.resize_impl(sso.size()-sizeof(T));
				if constexpr (isString()) writeNullTerminator((uint8_t*) end());
				
				return where;
				}
				
			const_iterator iend = cend();
			iterator inext = where;
			inext++;
			iterator itt = where;
		
			// erase this
			itt->~T();
			// move in place
			for (; inext != iend; itt = inext, inext++)
				new (itt) T(std::move(*inext));
				
			sso.resize_impl(sso.size()-sizeof(T), false);
			return where;
			}
			
		iterator erase (iterator first, iterator last) {
			const storage_size_t count = (last - first);
			if constexpr (isPod()) {
				// if pod then just memmove
				//printf("ERASE %i, %i %i", size(), first-begin(), last-begin());
				//assert(last-begin() <= size());
				
				iterator iend = end();
				if (last > iend)
					last = iend;
				if (last != iend)
					stt_memmove((uint8_t*) first, (uint8_t*) last, (iend - last)*sizeof(T));
				
				sso.resize_impl(sso.size()-sizeof(T)*count);
				if constexpr (isString()) writeNullTerminator((uint8_t*) end());
				
				return first;
				}
				
			//iterator ibegin = begin();
			// destroy first
			for (iterator itt = first; itt != last; ++itt)
				itt->~T();
			
			const_iterator iend = cend();
			iterator inext = first;
			inext += count;
			iterator itt = first;// ibegin + (first - ibegin); // needed for const correctness
			
			// move in place
			for (; inext != iend; ++itt, ++inext)
				new (itt) T(std::move(*inext));
			
			sso.resize_impl(sso.size()-sizeof(T)*count, false);
			return first;
			}
			
		iterator insert (iterator where, const T& value) {
			return insert(where, 1, value);
			}
			
		iterator insert (iterator where, const storage_size_t n, const T& value) {
			iterator where2 = insert_impl_make_room_sub(where, n); // invalidates where
			//printf("insert(): after make room but before filling\n");
			//sso.dbg_dump_row();
			
			objectFillRangeValueInPlace(where2, where2 + n, value);
			
			return where2;
			}
			
		iterator insert (iterator where, const T* first, const T* last) {
			// Inserts with copy semantics
			iterator where2 = insert_impl_make_room_sub(where, last - first); // invalidates where, where->where+(last-first) is now invalid memory
			insert_impl_copy_sub<true>(where2, first, last);
			return where2;
			}
		
		template<typename Iter>
		iterator insert(iterator where, stt::move_iterator<Iter> first, stt::move_iterator<Iter> last) {
			return insert_move(where, first.base(), last.base());
			}
			
		iterator insert_move (iterator where, T* first, T* last) {
			// Inserts with move semantics
			iterator where2 = insert_impl_make_room_sub(where, last - first); // invalidates where, where->where+(last-first) is now invalid memory
			insert_impl_move_sub<true>(where2, first, last);
			return where2;
			}

protected:
		iterator insert_impl_make_room_sub (iterator where, const storage_size_t count) {
			// working with itterators is awkward			
			const storage_size_t idx = where - begin(); // index (in elements)
			const storage_size_t sz_init = size();      // size (in elements)
			
			sso.resize_impl(sizeof(T)*(sz_init + count), false);
			
			// move things out of the way
			iterator ibegin_afterResize = begin();
			iterator ibegin = ibegin_afterResize + idx;   // position of where in the original array
			iterator realEnd = ibegin_afterResize + (sz_init + count);
			
			
			if constexpr (isPod()) {
				iterator dst = ibegin + count;
				iterator src = ibegin;
				stt_memmove((uint8_t*) dst, (uint8_t*) src, (sz_init - idx)*sizeof(T));
				if constexpr (isString()) writeNullTerminator((uint8_t*) realEnd);
				}
			else {
				iterator dst = realEnd - 1;
				iterator src = dst - count;
				iterator onePastIBegin = ibegin - 1;
				
				for (; src != onePastIBegin; --dst, --src) {
					//int elemDst = dst - ibegin_afterResize;
					//int elemSrc = src - ibegin_afterResize;
					//printf("\tmoving %i -> %i\n", elemSrc, elemDst);
					*dst = std::move(*src); // src is now undefined
					}
				}
			return ibegin;
			}
		
		template <bool doOverride>
		void insert_impl_copy_sub (iterator where, const T* first, const T* last) {
			iterator dst = where;
			if constexpr (isPod()) {
				stt_memcpy((uint8_t*) dst, (uint8_t*) first, (last-first)*sizeof(T));
				//if constexpr (isString()) if (isAppending) writeNullTerminator((uint8_t*) end());		
				}
			else {
				const T* src = first;
				for (; src != last; src++, dst++) {
					if constexpr (doOverride)
						new (dst) T(*src);	// we are overriding invalid memory so we may construct in place
					else
						*dst = *src;
					}
				}
			}
			
		template <bool doOverride>
		void insert_impl_move_sub (iterator where, T* first, T* last) {
			iterator dst = where;
			if constexpr (isPod()) {
				stt_memcpy((uint8_t*) dst, (uint8_t*) first, (last-first)*sizeof(T));
				//if constexpr (isString()) if (isAppending) writeNullTerminator((uint8_t*) end());		
				}
			else {
				T* src = first;
				for (; src != last; src++, dst++) {
					if constexpr (doOverride)
						new (dst) T(std::move(*src));	// we are overriding invalid memory so we may construct in place
					else
						*dst = std::move(*src);
					}
				}
			}

public:
		static const char* dbg_get_class_name() {
			#if STT_STL_DEBUG
			return __PRETTY_FUNCTION__;
			#else
			return "<stt_stl_vector>";
			#endif
			}
		};
	}
	
#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_vector
#define STT_STL_IMPL_DOUBLE_GUARD_vector
#define LZZ_OVERRIDE
// vector.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_vector
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// string.hh
//

#ifndef LZZ_string_hh
#define LZZ_string_hh

//#define STT_STRING_TYPE_TEMPLATE_DECL  class STRING_TYPE, typename std::enable_if<std::has_cstr<STRING_TYPE>{}, bool>::type = true
//#define STT_STRING_TYPE_TEMPLATE_DECL  class STRING_TYPE, typename std::enable_if<std::is_member_function_pointer<decltype(&(STRING_TYPE::c_str))>{}, bool>::type = true
//#define STT_STRING_TYPE_TEMPLATE_DECL  class STRING_TYPE, typename std::enable_if<stt::is_string_class<STRING_TYPE>::value, bool>::type = true


#define STT_STRING_TYPE_TEMPLATE_DECL            class STRING_TYPE, typename std::enable_if<stt::is_string_or_string_view_type<STRING_TYPE>::value, bool>::type = true
#define STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER  class STRING_TYPE, typename std::enable_if<stt::is_string_or_string_view_type_and_not_stt_string<STRING_TYPE>::value, bool>::type = true
#define STT_STRING_TYPE_TEMPLATE_DECL2           class STRING_TYPE, class STRING_TYPE2, typename std::enable_if<stt::is_string_or_string_view_type<STRING_TYPE>::value, bool>::type = true, typename std::enable_if<stt::is_string_or_string_view_type<STRING_TYPE2>::value, bool>::type = true
             
             
//#include <iterator>
namespace stt {
	// Has_c_str
	// Templates use c_str() method detection to determine if a passed objecet is some kind of string
	
	template <typename T> auto has_c_str_impl(int) -> decltype(std::declval<T>().c_str(), std::true_type{});
	template <typename T> auto has_c_str_impl(...) -> std::false_type;
	template <typename T>
	using has_c_str = decltype(has_c_str_impl<T>(0));
	
	template <typename T> auto has_substr_impl(int) -> decltype(std::declval<T>().substr(), std::true_type{});
	template <typename T> auto has_substr_impl(...) -> std::false_type;
	template <typename T>
	using has_substr = decltype(has_substr_impl<T>(0));
	
	template <typename T> auto not_has_stt_sbt_function_tag_impl(int) -> decltype(std::declval<T>().stt_sbt_function_tag(), std::false_type{});
	template <typename T> auto not_has_stt_sbt_function_tag_impl(...) -> std::true_type;
	template <typename T>
	using not_has_stt_sbt_function_tag = decltype(not_has_stt_sbt_function_tag_impl<T>(0));
	
	template <typename T>
	using is_string_or_string_view_type = std::disjunction<stt::has_c_str<T>, stt::has_substr<T>>;
	
	template <typename T>
	using is_string_or_string_view_type_and_not_stt_string = std::conjunction<stt::not_has_stt_sbt_function_tag<T>, std::disjunction<stt::has_c_str<T>, stt::has_substr<T>> >;

	// Stringview alias
	using string_view = std::string_view;
#if __cplusplus >= 202002L
	using weak_ordering = std::weak_ordering;
#endif
	//using span = std::span;
	
	
	template <unsigned int N, typename SSO_SIZE_T>
	class string_base_traits;
	
	template <unsigned int N>
	using string_base = string_base_traits<N, uint8_t>;
	
	using string24 = string_base<24>; // warning: vector24 will alias if capacity > (2^24-1)
	using string32 = string_base<32>;
	using string64 = string_base<64>;
	using string128 = string_base<128>;	// 127 + room for an int
	using string256 = string_base_traits<256, uint16_t>; // 252 + room for an int16
	
	
	template <unsigned int N, typename SSO_SIZE_T>
	class string_base_traits : public vector_base_traits<char, stt::sso_null_terminated_pod_tag, N, SSO_SIZE_T, false> {
	public:
		using base_type = vector_base_traits<char, stt::sso_null_terminated_pod_tag, N, SSO_SIZE_T, false>;
		using iterator = typename base_type::iterator;
		using const_iterator = typename base_type::const_iterator;
		using reference      = typename base_type::reference;
		using const_reference = typename base_type::const_reference;
		using reverse_iterator =  typename base_type::reverse_iterator;
		using const_reverse_iterator = typename base_type::const_reverse_iterator;
	
		static const string_size_t npos = -1;
		inline char* stt_sbt_function_tag() { return NULL; } // used for template detection
		
		// ============================
		// Constructors
		
		inline string_base_traits()  noexcept : base_type() {}
		//inline ~string_base_traits() noexcept { ~base_type(); }
		
		// Default copy constructor, move constructor, copy operator=
		// just use auto generated constructors and fall through to
		// the relevent vector_base_traits<...>'
		string_base_traits(const string_base_traits& other) = default;
		string_base_traits(string_base_traits&& other) = default;
		string_base_traits& operator = (const string_base_traits& other) = default;
		
		inline string_base_traits(allocatorI* alloc) noexcept : base_type() { this->sso.setAllocator(alloc); }
				
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits(const STRING_TYPE& s) noexcept {
			this->sso.init();
			this->append(s.data(), s.size());
			}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits(const STRING_TYPE& str, const string_size_t pos, const string_size_t len = npos) noexcept {
			this->sso.init();
			this->append(str, pos, len);
			}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits(STRING_TYPE&& s) noexcept {
			if constexpr (std::is_lvalue_reference<STRING_TYPE>::value) {
				// This captures STRING_TYPE = string_base_traits& cases
				//printf("moveConstruct copy construct %s, [%s]\n", __PRETTY_FUNCTION__, s.c_str());
				this->sso.init();
				this->append(s.data(), s.size());
				return;
				}
			// Move constuct with a mystery type
			//printf("moveConstruct %s, [%s]\n", __PRETTY_FUNCTION__, s.c_str());
			this->sso.init();
			move_assign(std::move(s));
			}
			
		string_base_traits(const char* s) noexcept {
			this->sso.init();
			this->append(s);
			}
			
		string_base_traits(const char* s, const string_size_t n) noexcept {
			this->sso.init();
			this->append(s, n);
			}
			
		string_base_traits(const string_size_t n, const char c) noexcept {
			this->sso.init();
			this->append(n, c);
			}
		
		template<typename Iter>
		string_base_traits(Iter first, Iter last) noexcept {
			this->sso.init();
			this->append((string_base_traits::const_iterator*) first, last - first);
			}
		
		string_base_traits (allocatorI* dataAllocator, const char* s, const string_size_t n) {
			// copy constructs and stores in custom allocator
			this->sso.init();
			this->setAllocator(dataAllocator);
			this->append(s, n);
			}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline string_base_traits (allocatorI* dataAllocator, const STRING_TYPE& s) {
			this->sso.init();
			this->setAllocator(dataAllocator);
			this->append(s);
			}
			
		// ============================
		// Interning
		
		inline void markInterned() { base_type::markInterned(); }
		inline bool isInterned () const { return base_type::isInterned(); }
		
		// ============================
		// Utility
		
		inline const char* c_str() const noexcept { return (const char*) this->sso.data(); }
		inline string_view to_string_view() const noexcept { return string_view(this->data(), this->size()); }
		inline string_base_traits substr (const string_size_t pos = 0, const string_size_t len = npos) const { return string_base_traits(*this, pos, len); }
		
		string_size_t copy (char* s, string_size_t len, string_size_t pos = 0) const {
			const string_size_t sz = this->size();
			if (pos >= sz) { stt::error::array_out_of_bounds(pos, sz); return 0; }
			string_size_t len2 = len;
			if (len2 > sz + pos)
				len2 = sz - pos;
			stt_memcpy((uint8_t*) s, (uint8_t*) &this->data()[pos], len2);
			return len2;
			}
		
		
		// ============================
		// Find
		// Rather than implementing this per type, just cast to string_view and use the already implemented functions
		
		// find
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_size_t find(const STRING_TYPE& str, const string_size_t pos = 0) const noexcept {
			return to_string_view().find(string_view(str.data(), (size_t) str.size()), pos);
			}
		inline string_size_t find (const char* s, const string_size_t pos = 0)                       const { return to_string_view().find(s, pos); }
		inline string_size_t find (const char* s, const string_size_t  pos, const string_size_t  n) const { return to_string_view().find(s, pos, n); }
		inline string_size_t find (char c, const string_size_t  pos = 0)              const noexcept { return to_string_view().find(c, pos); }
				
		// find_first_not_of
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline string_size_t find_first_not_of (const STRING_TYPE& str, const string_size_t pos = 0) const noexcept { 
			return to_string_view().find_first_not_of(string_view(str.data(), str.size()), pos);
			}
		inline string_size_t find_first_not_of (const char* s, const string_size_t pos = 0)                     const { return to_string_view().find_first_not_of(s, pos); }
		inline string_size_t find_first_not_of (const char* s, const string_size_t pos, const string_size_t n) const { return to_string_view().find_first_not_of(s, pos, n); }
		inline string_size_t find_first_not_of (char c, const string_size_t pos = 0)                   const noexcept { return to_string_view().find_first_not_of(c, pos); }
	
		// find_first_of
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline string_size_t find_first_of (const STRING_TYPE& str, const string_size_t pos = 0) const noexcept { 
			return to_string_view().find_first_of(string_view(str.data(), str.size()), pos);
			}
		inline string_size_t find_first_of (const char* s, const string_size_t pos = 0)                     const { return to_string_view().find_first_of(s, pos); }
		inline string_size_t find_first_of (const char* s, const string_size_t pos, const string_size_t n) const { return to_string_view().find_first_of(s, pos, n); }
		inline string_size_t find_first_of (char c, const string_size_t pos = 0)                   const noexcept { return to_string_view().find_first_of(c, pos); }
		
		// find_last_not_of
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline string_size_t find_last_not_of (const STRING_TYPE& str, const string_size_t pos = npos) const noexcept { 
			return to_string_view().find_last_not_of(string_view(str.data(), str.size()), pos);
			}
		inline string_size_t find_last_not_of (const char* s, const string_size_t pos = npos)                  const { return to_string_view().find_last_not_of(s, pos); }
		inline string_size_t find_last_not_of (const char* s, const string_size_t pos, const string_size_t n) const { return to_string_view().find_last_not_of(s, pos, n); }
		inline string_size_t find_last_not_of (char c, const string_size_t pos = npos)                const noexcept { return to_string_view().find_last_not_of(c, pos); }
		
		// find_last_not_of
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline string_size_t find_last_of (const STRING_TYPE& str, const string_size_t pos = npos) const noexcept { 
			return to_string_view().find_last_of(string_view(str.data(), str.size()), pos);
			}
		inline string_size_t find_last_of (const char* s, const string_size_t pos = npos)                  const { return to_string_view().find_last_of(s, pos); }
		inline string_size_t find_last_of (const char* s, const string_size_t pos, const string_size_t n) const { return to_string_view().find_last_of(s, pos, n); }
		inline string_size_t find_last_of (char c, const string_size_t pos = npos)                const noexcept { return to_string_view().find_last_of(c, pos); }
		
		
		// ============================
		// rfind
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline string_size_t rfind (const STRING_TYPE& str, const string_size_t pos = npos) const noexcept {
			return to_string_view().rfind(string_view(str.data(), str.size()), pos);
			}
		
		inline string_size_t rfind (const char* s, const string_size_t pos = npos) const                 { return to_string_view().rfind(s, pos); }
		inline string_size_t rfind (const char* s, const string_size_t pos, const string_size_t n) const { return to_string_view().rfind(s, pos, n); }
		inline string_size_t rfind (char c, const string_size_t pos = npos) const noexcept               { return to_string_view().rfind(c, pos); }
		
		// ============================
		// Compare
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline int compare (const STRING_TYPE& str) const noexcept {
			return to_string_view().compare(0, str.size(), str.data());
			}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline int compare (const string_size_t pos, const string_size_t len, const STRING_TYPE& str) const {
			return to_string_view().compare(pos, len, str.data(), str.size());
			}

		template <STT_STRING_TYPE_TEMPLATE_DECL>
		inline int compare (const string_size_t pos, const string_size_t len, const STRING_TYPE & str, const string_size_t subpos, const string_size_t sublen) const {
			return to_string_view().compare(pos, len, string_view(str.data(), str.size()), subpos, sublen);
			}
		
		inline int compare (const char* s) const { return to_string_view().compare(0, npos, s);  }	
		inline int compare (const string_size_t pos, const string_size_t len, const char* s) const                         { return to_string_view().compare(pos, len, s);    }
		inline int compare (const string_size_t pos, const string_size_t len, const char* s, const string_size_t n) const { return to_string_view().compare(pos, len, s, n); }

		// ============================
		// Insert
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& insert (const string_size_t pos, const STRING_TYPE& str) {
			const char* src = str.data();
			base_type::insert(this->begin() + pos, src, src + str.size());
			return *this;
			}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& insert (const string_size_t pos, const STRING_TYPE& str, const string_size_t subpos, const string_size_t sublen = npos){
			const char* src = str.data();
			base_type::insert(this->begin() + pos, src + subpos, src + subpos + sublen);
			return *this;
			}
		
		string_base_traits& insert (const string_size_t pos, const char* s) {
			base_type::insert(this->begin() + pos, s, s + stt_strlen(s));
			return *this;
			}
		
		string_base_traits& insert (const string_size_t pos, const char* s, const string_size_t n) {
			base_type::insert(this->begin() + pos, s, s + n);
			return *this;
			}
			
		string_base_traits& insert (const string_size_t pos, const string_size_t n, const char c) {
			base_type::insert(this->begin() + pos, n, c);
			return *this;
			}
			
		iterator insert (const_iterator p, const string_size_t n, const char c) {
			const string_size_t idx = p - this->cbegin();
			base_type::insert(this->begin() + idx, n, c);
			return this->begin() + idx;
			}
		
		iterator insert (const_iterator p, char c) {
			const string_size_t idx = p - this->cbegin();
			base_type::insert(this->begin() + idx, 1, c);
			return this->begin() + idx;
			}
			
		string_base_traits& insert (const_iterator p, const char* first, const char* last) {
			const string_size_t idx = p - this->cbegin();
			base_type::insert(this->begin() + idx, first, last);
			return *this;
			}

		// ============================
		// Erase
		string_base_traits& erase (string_size_t pos = 0, string_size_t len = npos) {
			iterator b = this->begin();
			string_size_t sz = this->size();
			if (len > sz - pos) len = sz - pos;
			base_type::erase(b + pos, b + pos + len);
			return *this;
			}
			
		inline iterator erase (const_iterator p) {
			iterator b = this->begin();
			return base_type::erase(b + (p-b));
			}
			
		inline iterator erase (const_iterator first, const_iterator last) {
			iterator b = this->begin();
			return base_type::erase(b + (first-b), b + (last-b));
			}
		
		// ============================
		// Replace
protected:
		void replace_worker_resize (const string_size_t pos, const string_size_t len, const string_size_t n) {
			iterator ptr = this->begin();
			if (len > n) {
				// remove excess chars
				base_type::erase(ptr + pos, ptr + pos + (len - n)); 
				}
			else {
				// insert dummy chars
				base_type::insert(ptr + pos, n - len, char(0));
				}
			}
			
		string_base_traits& replace_worker (const string_size_t pos, const string_size_t len, const char* first, const string_size_t n) {
			replace_worker_resize(pos, len, n);
			stt_memcpy((uint8_t*) this->begin() + pos, (uint8_t*) first, n);
			return *this;
			}
		
		string_base_traits& replace_worker_fill (const string_size_t pos, const string_size_t len, const string_size_t n, const char c) {
			replace_worker_resize(pos, len, n);
			stt_memset((uint8_t*) this->begin() + pos, c, n);
			return *this;
			}
		
public:
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& replace (const string_size_t pos, const string_size_t len, const STRING_TYPE & str) {
			return replace_worker(pos, len, str.data(), str.size());
			}
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& replace (const_iterator i1, const_iterator i2, const STRING_TYPE& str) {
			return replace_worker (i1 - this->cbegin(), i2 - i1, str.data(), str.size());
			}
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& replace (const string_size_t pos, const string_size_t len, const STRING_TYPE& str, string_size_t subpos, string_size_t sublen = npos) {
			if (subpos > str.size()) subpos = str.size();
			if (sublen > str.size() - subpos) sublen = str.size() - subpos;
			return replace_worker(pos, len, str.data() + subpos, sublen);
			}

		string_base_traits& replace (const string_size_t pos, const string_size_t len, const char* s) {
			return replace_worker(pos, len, s, stt_strlen(s));
			}
			
		string_base_traits& replace (const string_size_t pos, const string_size_t len, const char* s, const string_size_t n) {
			return replace_worker(pos, len, s, n);
			}

		string_base_traits& replace (const_iterator i1, const_iterator i2, const char* s) {
			return replace_worker (i1 - this->cbegin(), i2 - i1, s, stt_strlen(s));
			}
			
		string_base_traits& replace (const_iterator i1, const_iterator i2, const char* s, const string_size_t n) {
			return replace_worker (i1 - this->cbegin(), i2 - i1, s, n);
			}
			
		string_base_traits& replace (const string_size_t pos, const string_size_t len, const string_size_t n, const char c) {
			return replace_worker_fill(pos, len, n, c);
			}
		
		string_base_traits& replace (const_iterator i1, const_iterator i2, const string_size_t n, const char c) {
			return replace_worker_fill(i1 - this->cbegin(), i2 - i1, n, c);
			}
		
		// ============================
		// Assign
		template <unsigned int N2, typename SSO_SIZE_T2>
		string_base_traits& assign (string_base_traits<N2,SSO_SIZE_T2>&& other) noexcept {
			//printf("move assign %s, [%s]\n", __PRETTY_FUNCTION__, str.c_str());
			move_assign(std::move(other));
			return *this;
			}
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& assign (const STRING_TYPE& str) noexcept {
			//printf("copy assign %s, [%s]\n", __PRETTY_FUNCTION__, str.c_str());
			this->sso.clear();
			return this->append (str);
			}
			
		string_base_traits& assign (const char* str) noexcept {
			this->sso.clear();
			return this->append (str);
			}
			
		string_base_traits& assign (const char* str, const string_size_t len) noexcept {
			this->sso.clear();
			return this->append (str, len);
			}
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& assign (const STRING_TYPE& str, const string_size_t pos, const string_size_t len = npos) noexcept {
			this->sso.clear();
			return this->append (str, pos, len);
			}
			
		string_base_traits& assign (const string_size_t len, const char c) {
			this->sso.clear();
			return append_impl(0, len, c);
			}
			
		string_base_traits& assign(const char * first, const char * last) {
			return assign(first, last - first);
			}
			
		// ============================
		// Append
		
		string_base_traits& append_impl (const string_size_t thisSz, const string_size_t len, const char c) noexcept {
			uint8_t* ptr = this->sso.reserve(thisSz + len, len);
			stt_memset(ptr, c, len);
			ptr[len] = 0;
			return *this;
			}
			
		template <unsigned int N2, typename SSO_SIZE_T2>
		string_base_traits& append (string_base_traits<N2,SSO_SIZE_T2>&& other) noexcept {
			if (this->empty()) {
				move_assign(std::move(other));
				return *this;
				}
			return append(other.data(), other.size());
			}
			
		//template <STT_STRING_TYPE_TEMPLATE_DECL>
		//string_base_traits& append (STRING_TYPE&& str) noexcept {
		//	//printf("move append %s, [%s]\n", __PRETTY_FUNCTION__, str.c_str());
		//	if (this->empty())
		//		return assign(std::move(str));
	//		return append(str.data(), str.size());
	//		}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& append (const STRING_TYPE& str) noexcept {
			return append(str.data(), str.size());
			}
		
		string_base_traits& append (const char* str) noexcept {
			return append(str, stt_strlen(str));
			}
			
		string_base_traits& append (const char* str, const string_size_t len) noexcept {
			// this is the thing that actually does the appending
			base_type::batch_append_copy(str, len);
			return *this;
			}
			
		string_base_traits& append (const string_size_t len, const char c) noexcept {
			append_impl(this->size(), len, c);
			return *this;
			}
			
		//template <typename STRING_TYPE, std::enable_if_t<std::is_same<typename STRING_TYPE::value_type, char>::value, bool> = true >
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& append (const STRING_TYPE& str, const string_size_t pos, const string_size_t len = -1) noexcept {
			append_substr(str.data(), str.size(), pos, len);
			return *this;
			}
			
		string_base_traits& append(const char * first, const char * last) {
			return append(first, last - first);
			}
			
protected:
		void append_substr (const char* str, const string_size_t srclen, const string_size_t pos, const string_size_t len = -1) noexcept {
			string_size_t len2 = len;
			if (len > srclen - pos)
				len2 = (srclen - pos);
			append (&str[pos], len2);
			}
public:
			
		// ============================
		// Operators
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& operator = (const STRING_TYPE & other) noexcept {
			assign(other.data(), other.size());
			return *this;
			}
			
		template <unsigned int N2, typename SSO_SIZE_T2>
		string_base_traits& operator = (string_base_traits<N2,SSO_SIZE_T2>&& other) noexcept {
			move_assign(std::move(other));
			return *this;
			}

		template <unsigned int N2, typename SSO_SIZE_T2>
		void move_assign (string_base_traits<N2,SSO_SIZE_T2>&& other) noexcept {
			// does this actually get called? Or does it automagically fall through to vector() move stuff?
			
			// move assign
			// 0. discard any local heap info
			// 1. if other is on the heap and cannot fit, transfer pointer
			// 2. if other is on the heap and can fit, pack into this sso and free heap
			// 3. else copy other sso to this sso
			
			//printf("move assign impl! %i [%s]", other.size(), other.c_str());
				
			if (!other.isUsingSso()) {
				// steal the data
				if (other.size() > this->sso.local_capcity()) {
					//printf("stealing store!");
					if (!this->isUsingSso())
						this->sso.d.store.deallocate();
					this->sso.d.store = other.sso.d.store;
					this->sso.disableSsoFlag();
					other.sso.set_local_size(0); // disables other store
					return;
					}
				}
			assign(other.data(), other.size());
			}
		
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		void move_assign (STRING_TYPE&& other) noexcept {
			// For std::string, etc, we cannot swap
			assign(other.data(), other.size());
			}
			
		string_base_traits& operator = (const char * arr) noexcept {
			return assign(arr);
			}
			
		template <STT_STRING_TYPE_TEMPLATE_DECL>
		string_base_traits& operator += (const STRING_TYPE & other) noexcept {
			return append(other);
			}
		string_base_traits& operator += (const char* other) noexcept {
			return append(other);
			}
		string_base_traits& operator += (const char c) noexcept {
			return append(1, c);
			}
			
		// helper functions for constructing with char/string_view with 1 copy
		void concat_impl(const char * a, const string_size_t alen, const char * b, const string_size_t blen) noexcept {
			// assumes that this is empty
			const string_size_t wantsSize = alen + blen;
			uint8_t* ptr = this->sso.reserve(wantsSize, wantsSize);
			stt_memcpy(ptr, (uint8_t*) a, alen);
			stt_memcpy(&ptr[alen], (uint8_t*) b, blen);
			ptr[wantsSize] = 0;
			}
			
		void concat_impl(const char a, const char * b, const string_size_t blen) noexcept {
			// assumes that this is empty
			const string_size_t wantsSize = blen + 1;
			uint8_t* ptr = this->sso.reserve(wantsSize, wantsSize);
			ptr[0] = a;
			stt_memcpy(&ptr[1], (uint8_t*) b, blen);
			ptr[wantsSize] = 0;
			}
			
		void concat_impl(const char * b, const string_size_t blen, const char c) noexcept {
			// assumes that this is empty
			const string_size_t wantsSize = 1 + blen;
			uint8_t* ptr = this->sso.reserve(wantsSize, wantsSize);
			stt_memcpy(ptr, (uint8_t*) b, blen);
			ptr[blen] = c;
			ptr[wantsSize] = 0;
			}
			
		// hash support
		inline size_t hash() const {
			return stt::hash_function((uint8_t*) this->data(), this->size());
			}
		
		// These need to be defined here otherwise std::equal_to cannot find them
		inline bool operator == (const string_base_traits & other) const { return to_string_view() == other.to_string_view(); }
		inline bool operator != (const string_base_traits & other) const { return to_string_view() != other.to_string_view(); }
		inline bool operator >= (const string_base_traits & other) const { return to_string_view() >= other.to_string_view(); }
		inline bool operator <= (const string_base_traits & other) const { return to_string_view() <= other.to_string_view(); }
		inline bool operator > (const string_base_traits & other) const { return to_string_view() > other.to_string_view(); }
		inline bool operator < (const string_base_traits & other) const { return to_string_view() < other.to_string_view(); }
		
		inline operator string_view() const { return to_string_view(); } 
		};
	}


// std::hash
template <unsigned int N, typename SSO_SIZE_T>
struct std::hash<stt::string_base_traits<N,SSO_SIZE_T>> {
    inline std::size_t operator()(const stt::string_base_traits<N,SSO_SIZE_T>& s) const noexcept {
		return s.hash();
		}
	};


// stream support
template <typename T, unsigned int N, typename SSO_SIZE_T>
T& operator<< (T& os, const stt::string_base_traits<N,SSO_SIZE_T> & str) {
	(os << str.to_string_view());
	return os;
	}

template <typename T, unsigned int N, typename SSO_SIZE_T>
T& operator>> (T& is, const stt::string_base_traits<N,SSO_SIZE_T> & str) {
	(str.assign(is.str()));
	return is;
	}


// + operators (of which there are many....)

// string operator+ (const string& lhs, const string& rhs);
// string operator+ (string&&      lhs, string&&      rhs);
// string operator+ (string&&      lhs, const string& rhs);
// string operator+ (const string& lhs, string&&      rhs);
template <unsigned int N, typename SSO_SIZE_T, unsigned int N2, typename SSO_SIZE_T2>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, const stt::string_base_traits<N2,SSO_SIZE_T2>& rhs) {
	stt::string_base_traits<N,SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs.data(), rhs.size());
	return r;
	}
	
template <unsigned int N, typename SSO_SIZE_T, unsigned int N2, typename SSO_SIZE_T2>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (stt::string_base_traits<N,SSO_SIZE_T>&& lhs, stt::string_base_traits<N2,SSO_SIZE_T2>&& rhs) {
	lhs.append(rhs);
	return lhs;
	}
	
template <unsigned int N, typename SSO_SIZE_T, unsigned int N2, typename SSO_SIZE_T2>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (stt::string_base_traits<N,SSO_SIZE_T>&& lhs, const stt::string_base_traits<N,SSO_SIZE_T>& rhs) {
	lhs.append(rhs);
	return lhs;
	}
	
template <unsigned int N, typename SSO_SIZE_T, unsigned int N2, typename SSO_SIZE_T2>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, stt::string_base_traits<N,SSO_SIZE_T>&& rhs) {
	rhs.insert(0, rhs);
	return lhs;
	}

// RHS is stt::string, LHS is any string type
// string operator+ (const string& lhs, const string& rhs);
// string operator+ (string&&      lhs, string&&      rhs);
// string operator+ (string&&      lhs, const string& rhs);
// string operator+ (const string& lhs, string&&      rhs);

template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const STRING_TYPE& lhs, const stt::string_base_traits<N,SSO_SIZE_T>& rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs.data(), rhs.size());
	return r;
	}

template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (STRING_TYPE&& lhs, stt::string_base_traits<N,SSO_SIZE_T>&& rhs) {
	return rhs.insert(0, lhs.data(), lhs.size());
	}
	
template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (STRING_TYPE&& lhs, const stt::string_base_traits<N,SSO_SIZE_T>& rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs.data(), rhs.size());
	return r;
	}
	
template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (const STRING_TYPE& lhs, stt::string_base_traits<N,SSO_SIZE_T>&& rhs) {
	return rhs.insert(0, lhs.data(), lhs.size());
	}
	
	
// LHS is stt::string, RHS is any string type
// string operator+ (const string& lhs, const string& rhs);
// string operator+ (string&&      lhs, stt::string&&      rhs);
// string operator+ (string&&      lhs, const string& rhs);
// string operator+ (const string& lhs, string&&      rhs);
template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, const STRING_TYPE& rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs.data(), rhs.size());
	return r;
	}

template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (stt::string_base_traits<N,SSO_SIZE_T>&& lhs, STRING_TYPE&& rhs) {
	return lhs.append(rhs);
	}
	
template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (stt::string_base_traits<N,SSO_SIZE_T>&& lhs, const STRING_TYPE& rhs) {
	return lhs.append(rhs);
	}
	
template <unsigned int N, typename SSO_SIZE_T, STT_STRING_TYPE_TEMPLATE_DECL_NOT_OTHER>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, STRING_TYPE&& rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs.data(), rhs.size());
	return r;
	}

// char*
// string operator+ (const string& lhs, const char*   rhs);
// string operator+ (string&&      lhs, const char*   rhs);
// string operator+ (const char*   lhs, const string& rhs);
// string operator+ (const char*   lhs, string&&      rhs);
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const stt::string_base_traits<N,SSO_SIZE_T> & lhs, const char * rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs, stt::stt_strlen(rhs));
	return r;
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (stt::string_base_traits<N,SSO_SIZE_T>&& lhs, const char * rhs) {
	return lhs.append(rhs);
	}
		
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const char * lhs, const stt::string_base_traits<N,SSO_SIZE_T> & rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs, stt::stt_strlen(lhs), rhs.data(), rhs.size());
	return r;
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (const char * lhs, stt::string_base_traits<N,SSO_SIZE_T>&& rhs) {
	return rhs.insert(0, lhs);
	}
	
// char
// string operator+ (const string& lhs, char          rhs);
// string operator+ (string&&      lhs, char          rhs);
// string operator+ (char          lhs, const string& rhs);
// string operator+ (char          lhs, string&&      rhs);
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, char rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs.data(), lhs.size(), rhs);
	return r;
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (stt::string_base_traits<N,SSO_SIZE_T>&& lhs, char rhs) {
	return lhs.append(1, rhs);
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T> operator+ (char lhs, const stt::string_base_traits<N,SSO_SIZE_T>& rhs) {
	stt::string_base_traits<N, SSO_SIZE_T> r;
	r.concat_impl(lhs, rhs.data(), rhs.size());
	return r;
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline stt::string_base_traits<N,SSO_SIZE_T>& operator+ (char lhs, stt::string_base_traits<N,SSO_SIZE_T>&& rhs) {
	return rhs.insert(0, lhs);
	}



// Relational operators
	
template <unsigned int N, typename SSO_SIZE_T>
inline bool operator== (const char * lhs, const stt::string_base_traits<N,SSO_SIZE_T>& rhs) {
	return stt::string_view(lhs, stt::stt_strlen(lhs)) == rhs.to_string_view();
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline bool operator== (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, const char * rhs) {
	return stt::string_view(rhs, stt::stt_strlen(rhs)) == lhs.to_string_view();
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline bool operator!= (const char * lhs, const stt::string_base_traits<N,SSO_SIZE_T>& rhs) {
	return stt::string_view(lhs, stt::stt_strlen(lhs)) != rhs.to_string_view();
	}
	
template <unsigned int N, typename SSO_SIZE_T>
inline bool operator!= (const stt::string_base_traits<N,SSO_SIZE_T>& lhs, const char * rhs) {
	return stt::string_view(rhs, stt::stt_strlen(rhs)) != lhs.to_string_view();
	}
	
// relational operators
// ==
template <STT_STRING_TYPE_TEMPLATE_DECL2>
inline bool operator==(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
	return stt::string_view(lhs.data(), lhs.size()) == stt::string_view(rhs.data(), rhs.size());
	}

#if __cplusplus >= 202002L
	template <STT_STRING_TYPE_TEMPLATE_DECL2>
	inline auto operator<=>(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
		return stt::string_view(lhs.data(), lhs.size()) <=> stt::string_view(rhs.data(), rhs.size());
		}
#else
	template <STT_STRING_TYPE_TEMPLATE_DECL2>
	inline bool operator!=(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
		return stt::string_view(lhs.data(), lhs.size()) != stt::string_view(rhs.data(), rhs.size());
		}
		
	template <STT_STRING_TYPE_TEMPLATE_DECL2>
	inline bool operator<=(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
		return stt::string_view(lhs.data(), lhs.size()) <= stt::string_view(rhs.data(), rhs.size());
		}
		
	template <STT_STRING_TYPE_TEMPLATE_DECL2>
	inline bool operator>=(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
		return stt::string_view(lhs.data(), lhs.size()) >= stt::string_view(rhs.data(), rhs.size());
		}
		
	template <STT_STRING_TYPE_TEMPLATE_DECL2>
	inline bool operator<(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
		return stt::string_view(lhs.data(), lhs.size()) < stt::string_view(rhs.data(), rhs.size());
		}
		
	template <STT_STRING_TYPE_TEMPLATE_DECL2>
	inline bool operator>(const STRING_TYPE & lhs, const STRING_TYPE2 & rhs) noexcept {
		return stt::string_view(lhs.data(), lhs.size()) > stt::string_view(rhs.data(), rhs.size());
		}
#endif

#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_string
#define STT_STL_IMPL_DOUBLE_GUARD_string
#define LZZ_OVERRIDE
// string.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_string
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// max_size_array.hh
//

#ifndef LZZ_max_size_array_hh
#define LZZ_max_size_array_hh

namespace stt {
struct msaSilentFailErrorHandler {
	static void throw_max_size_error(void* _ptr) {}
	};
	
struct msaAbortErrorHandler {
	static void throw_max_size_error(void* _ptr) { STT_STL_ABORT(); }
	};
	
template <typename T, uint32_t MAX_ELEMENTS, typename SIZE_TYPE = uint8_t, typename ErrorHandler = stt::msaAbortErrorHandler>
class maxSizeArray {
public:
	// Purpose: drop in replacement for std::vector where you know the
	// size of the vector will not exceed a fixed size
	//
	using iterator       = T*;
	using const_iterator = const T*;
	using size_type = storage_size_t;
	using reference      = T&;
	using const_reference = const T&;
	using reverse_iterator = stt::reverse_iterator<iterator>;
	using const_reverse_iterator = stt::reverse_iterator<const_iterator>;
	typedef T value_type;
		
	uint8_t buff[MAX_ELEMENTS*sizeof(T)];
	SIZE_TYPE mSize;
	
	static_assert(SIZE_TYPE(-1) >= MAX_ELEMENTS);
	
	inline T* data() { return (T*) &buff[0]; }
	inline const T* data() const { return (T*) &buff[0]; }
	
	inline T& operator [] (const uint32_t idx) { return data()[idx]; }
	inline const T& operator [] (const uint32_t idx) const { return data()[idx]; }
	inline T& at(const uint32_t idx) { return data()[idx]; }
	inline const T& at(const uint32_t idx) const { return data()[idx]; }
	
	// get - returns a pointer to the object at (idx). Useful for lua bindings of arrays of objects without copying
	inline T* get(const uint32_t idx) { return &(data()[idx]); }
	inline const T* getC(const uint32_t idx) const { return &(data()[idx]); }
		
	inline uint64_t size_bytes() const noexcept { return mSize*sizeof(T); }
	inline storage_size_t size() const noexcept { return mSize; }
	inline storage_size_t length() const noexcept   { return mSize; }
	inline static constexpr storage_size_t capacity() { return MAX_ELEMENTS; }
	inline static constexpr storage_size_t max_size() { return MAX_ELEMENTS; }
	
	inline const_iterator cbegin() const noexcept { return const_iterator(data()); }
	inline const_iterator cend()   const noexcept { return const_iterator(data() + size()); };
	inline const_iterator begin() const noexcept { return const_iterator(data()); }
	inline const_iterator end()   const noexcept { return const_iterator(data() + size()); };
	inline iterator begin() noexcept { return iterator(data()); }
	inline iterator end()   noexcept { return iterator(data() + size()); }
	
	inline reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
	inline reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
	inline const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }
	inline const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }
	inline const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
	inline const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }
		
	inline bool empty() const { return !mSize; }
	
	inline T& front()             { return data()[0]; }
	inline const T& front() const { return data()[0]; }
	inline T& back()             { return data()[size()-1]; }
	inline const T& back() const { return data()[size()-1]; }
	
	
	inline void clear() {
		if constexpr (requires_destroy_on_resize<T>::value)
			objectDestroyRange(data(), data() + mSize); 
		mSize = 0;
		}
	
	inline void resize(const uint32_t sz) {
		if (sz > MAX_ELEMENTS) {
			if constexpr (requires_fill_on_resize<T>::value)
				objectFillRangeInPlace(data() + mSize, data() + MAX_ELEMENTS);
			mSize = MAX_ELEMENTS;
			return ErrorHandler::throw_max_size_error(this);
			}
			
		if constexpr (requires_fill_on_resize<T>::value)
			if (sz > mSize)
				objectFillRangeInPlace(data() + mSize, data() + sz);
		
		if constexpr (requires_destroy_on_resize<T>::value)
			if (sz < mSize)
				objectDestroyRange(data() + sz, data() + mSize);
		
		mSize = sz;
		}
	
	inline void reserve(const uint32_t sz) {
		if (sz > MAX_ELEMENTS)
			return ErrorHandler::throw_max_size_error(this);
		}
		
	inline void pop_back() {
		const storage_size_t sz = size();
		if (sz)
			resize(sz-1);
		}
		
	inline void push_back(const T & a) {
		if (mSize >= MAX_ELEMENTS) return ErrorHandler::throw_max_size_error(this);
		data()[mSize] = a;
		mSize++;
		}
		
	inline void push_back(T&& a) {
		if (mSize >= MAX_ELEMENTS) return ErrorHandler::throw_max_size_error(this);
		new (data() + mSize) T(std::move(a)); // move construct in place
		mSize++;
		}
	
	// alias of push_back for lua binding
	inline void push_back_luasafe(const T & a) { push_back(a); }
	
	inline maxSizeArray() : mSize(0) {}
		
	inline ~maxSizeArray() {
		clear();
		}
	
	};
}

#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_max_size_array
#define STT_STL_IMPL_DOUBLE_GUARD_max_size_array
#define LZZ_OVERRIDE
// max_size_array.cpp
//

#define LZZ_INLINE inline
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_max_size_array
#endif //STT_STL_IMPL_IMPL
