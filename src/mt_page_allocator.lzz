#hdr
#end

#src
#end

namespace stt {
class ThreadSafePageAllocator {
	// Public facing api for the allocator
public:
	static void initThreadLocalAllocators() {
		// MUST be called on thread startup!
		ThreadSafePageAllocatorImpl::get().initThreadLocalAllocators();
		}
	static void cleanupThreadLocalAllocators() {
		// MUST be called on thread end!
		ThreadSafePageAllocatorImpl::get().cleanupThreadLocalAllocators();
		}
	static PATL_Data* getThreadLocalAllocators() {
		return ThreadSafePageAllocatorImpl::get().getThreadLocalAllocators();
		}
	
	// PageI
	static pageI* allocPage() {
		// Allocates a single pageI
		pageI* arr[1];
		ThreadSafePageAllocatorImpl::get().allocPages(&arr[0], 1);
		return arr[0];
		}
	static void freePage(pageI* page) {
		pageI* arr[1];
		arr[0] = page;
		ThreadSafePageAllocatorImpl::get().freePages(&arr[0], 1);
		}
	static void allocPages(pageI** pages, const uint32_t nPages) { ThreadSafePageAllocatorImpl::get().allocPages(pages, nPages); }
	static void freePages(pageI** pages, const uint32_t nPages)  { ThreadSafePageAllocatorImpl::get().freePages(pages, nPages); }
	// Because a array of pages is internally converted into a linked list it is more efficent a linked list directly
	static void freePagesList(pageI* pageLinkedList) { ThreadSafePageAllocatorImpl::get().freePagesList(pageLinkedList); }
	};
	
namespace ThreadSafePageAllocatorTemplates {
	// Used for template stuff that is forbidden in classes
	template<typename T> T*   allocGeneric()    { abort(); return NULL; }
	template<typename T> void freeGeneric(T* t) { abort(); }
	template<typename T> void allocGenericBatch(T** t, const uint32_t n) { abort(); }
	template<typename T> void freeGenericBatch (T** t, const uint32_t n) { abort(); }
	template<typename T> void freeGenericList(T* t) { abort(); }
	
	
	template<> inline pageI* allocGeneric()      { return ThreadSafePageAllocator::allocPage(); }
	template<> inline void freeGeneric(pageI* t) { ThreadSafePageAllocator::freePage(t); }
	template<> inline void allocGenericBatch(pageI** t, const uint32_t n) { ThreadSafePageAllocator::allocPages(t, n); }
	template<> inline void freeGenericBatch (pageI** t, const uint32_t n) { ThreadSafePageAllocator::freePages(t, n); }
	template<> inline void freeGenericList(pageI* t) { ThreadSafePageAllocator::freePagesList(t); }
	}
}
