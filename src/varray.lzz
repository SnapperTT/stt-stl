#hdr
// Purpose: drop in replacement for vla
// int len = 5;
// int arr[len];
// 
// Replace with:
// int len = 5;
// stt::varray<int, 512> arr(len, someAllocatorI);

namespace stt {
	class allocatorI;
	}
#end

#src
#include "allocator.hh"
#end

namespace stt {
template <typename T, uint32_t stackCapacity>
class varray {
public:
	uint8_t buff[stackCapacity*sizeof(T)];
	T* data;
	allocatorI * alloc;
	uint32_t size;
	
	varray(const uint32_t _size, allocatorI* _alloc = NULL) {
		if (_size <= stackCapacity) {
			data = (T*) &buff[0];
			alloc = NULL;
			size = _size;
			}
		else {
			const alloc_size_t wantsSize = _size*sizeof(T);
			alloc = _alloc;
			if (!alloc)
				alloc = crt_allocator::getStaticCrtAllocator();
			data = (T*) alloc->allocate(wantsSize);
			size = _size;
			}
		if constexpr (requires_fill_on_resize<T>::value) {
			objectFillRangeInPlace<T>(&data[0], &data[size]);
			}
		}
		
	~varray() {
		if constexpr (requires_destroy_on_resize<T>::value) {
			objectDestroyRange<T>(&data[0], &data[size]);
			}
		if (alloc)
			alloc->deallocate((uint8_t*) data, size*sizeof(T));
		}
	
	inline T& operator [] (const uint32_t idx) { return data[idx]; }
	inline const T& operator [] (const uint32_t idx) const { return data[idx]; }
	};
}
