#hdr
//#define STT_STL_DEBUG 1
//#define STT_STL_DEBUG_MEMORY 1
//#define STT_STL_DEBUG_PAGE 1
#include "stt-stl.h"
#define STT_STL_IMPL 1
#end


#src
#define STT_STL_IMPL 1
#include "stt-stl.h"
#include "stt-pages.h"

#include <iostream>
#end


struct biglyInt {
	int64_t value;
	int64_t padding[63];
	};


int main (int argc, char ** argv) {
	stt::ThreadSafePageAllocator::initThreadLocalPools(); // must be called at the start of the thread
	
	// allocate and destroy some stuff
	stt::pageU* p = stt::ThreadSafePageAllocator::allocPage();
	stt::pageU* pp[13];
	stt::ThreadSafePageAllocator::allocPages(&pp[0], 13); // bulk alloc
	stt::ThreadSafePageAllocator::freePage(p);
	stt::ThreadSafePageAllocator::freePages(&pp[0], 13); // bulk free
	
	// test a page queue
	{
	stt::pageQueue<biglyInt> pq;
	stt::stt_dbg_log("Pushing back into pq....\n");
	for (int i = 0; i < 10; ++i) {
		biglyInt bi; bi.value = i;
		pq.push_back(std::move(bi));
		}
	
	printf("pq values....\n");
	for (const biglyInt& a : pq)
		stt::stt_dbg_log("\t%li\n", a.value);
		
	for (auto itt = pq.begin() ; itt != pq.end(); ++itt) {
		stt::stt_dbg_log("\t%p: %li\n", itt.currentPage, (*itt).value);
		}
	}
	
	
	// test a page-based allocator and interning data within
	{
		stt::string24 testStr = "The quick brown fox jumped over the lazy log 1234567890abcdefghijklmnopqrstuvwxyz";
		stt::pageQueueBumpAllocator<stt::pageU> store;
		
		stt::vector24<stt::string_view> svs;
		svs.setAllocator(&store);
		
		// using a hint can speed up push_back_compact in a loop
		stt::pageQueueBumpAllocator<stt::pageU>::pushBackLookupHint mHint;
		
		for (uint i = 0; i < 100; ++i) {
			svs.push_back(store.push_back_compact(testStr, &mHint));
			stt::stt_dbg_log("INSERT: %i svs: [%p, %i] %.*s\n", i, svs[i].data(), int(svs[i].size()), int(svs[i].size()), svs[i].data());
			}
		
		for (uint i = 0; i < 100; ++i) {
			stt::stt_dbg_log("READ: %i svs: [%p, %i] %.*s\n", i, svs[i].data(), int(svs[i].size()), int(svs[i].size()), svs[i].data());
			}
	}

	// Test jumbo and giga
	{
	stt::jumboPageU* jp = stt::ThreadSafePageAllocator::allocJumboPage();
	stt::megaPageU* gp = stt::ThreadSafePageAllocator::allocMegaPage();

	stt::stt_dbg_log("Jumbo test: %p (%i bytes), Mega test: %p (%i bytes)\n", jp, int(jp->capacity()), gp, int(gp->capacity()));
			
	stt::ThreadSafePageAllocator::freeJumboPage(jp);
	stt::ThreadSafePageAllocator::freeMegaPage(gp);
	}

	// Varray Test
	struct AConstruct {
		uint8_t a;
		AConstruct () {
			stt::stt_dbg_log("AConstruct\n");
			}
		};
	struct BDestruct {
		uint8_t a;
		~BDestruct () {
			stt::stt_dbg_log("BDestruct\n");
			}
		};
	{
		stt::varray<AConstruct,10> AArr(5);
		stt::varray<BDestruct,2> BArr(5);
		stt::stt_dbg_log("A is heap: %b, B is heap: %b\n", AArr._alloc != NULL, BArr._alloc != NULL);
	}

	// Cleanup - 
	// If you are exiting the program you can just ::exit() and forgo cleanup
	
	stt::ThreadSafePageAllocator::cleanupThreadLocalPools(); // must be called at the end of a thread, this call cleans up *this* thread's pool and destroys local storage
	stt::ThreadSafePageAllocator::cleanupBackendPools(); // must be called on program shutdown to free all pages in the backend pool to system memory
	return 1;
	}
