#hdr
template<typename V, typename T, unsigned int N>
struct vector_ref_impl {
	// Wrapper for vector so that vectors of forward declared types
	// can be used (as long as no functions are called!)
	// 
	// This hides classes vector and T from the header
	//
	// if, eg vector24<T> causes compiler errors due to incomplete type then
	// replace with vector_proxy24<T>
	//
	// If this is a member variable then
	// consturct vector and destroy vector MUST be called 
	// in the class that owns this
	//
	uint8_t _padding[N];
	
	vector_ref_impl () {}

	inline constexpr V& v() { return *((V*) &vector_padding[0]); }
	inline constexpr const V& v() const { return *((V*) &vector_padding[0]); }
	inline constexpr operator V& () { return v(); }
	inline constexpr operator const V& () const { return v(); }
	
	inline size_t size() const { const V& v = *this; return v.size(); }
	inline void resize(const size_t sz) { V& v = *this; v.resize(sz); }
	inline void reserve(const size_t sz) { V& v = *this; v.reserve(sz); }
	inline T& operator [](const size_t idx) { V& v = *this; return v[idx]; }
	inline const T& operator [](const size_t idx) const { const V& v = *this; return v[idx]; } 
	
	
	void manualConstructInPlace() {
		// manual construciton
		static_assert(sizeof(vector_proxy_impl) == sizeof(V));
		new (&vector_padding[0]) V();
		}
		
	void manualDestroyInPlace() {
		// manual destruction
		V& v = *this;
		v.~V();
		}
	
	};
	
template<typename T> using vector_proxy24 = vector_proxy_impl<stt::vector24<T>, T, 24>;
template<typename T> using vector_proxy32 = vector_proxy_impl<stt::vector32<T>, T, 32>;
template<typename T> using vector_proxy64 = vector_proxy_impl<stt::vector64<T>, T, 64>;
#end

#src
#end
