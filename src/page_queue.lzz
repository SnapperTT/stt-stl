#define STT_PAGEQUEUE_NOCOPY(X) \
private:								\
	X(const X& other);					\
	X& operator =(const X & other);		\
public:	

#hdr
namespace stt {
	template<typename T, typename P>
	struct pageQueueImpl;
	
	template <typename T>
	using pageQueue = pageQueueImpl<T,pageU>;
	}

#define STT_PAGEQUEUE_MVSEM pageQueueImpl&&
#end

#src
#end

namespace stt {
	template<typename T, typename P>
	struct pageQueueImpl {
		P* head;
		P* tail;
		
		struct iterator {
			T* ptr;
			T* localEnd;
			P* currentPage;
			uint32_t idx;
			
			void init(P* page) {
				currentPage = page;
				if (currentPage) {
					ptr = pageQueueImpl::pagePtr(currentPage);
					localEnd = &ptr[currentPage->ph.localSize];
					}
				else {
					ptr = NULL;
					localEnd = NULL;
					}
				}
			
			inline void incr() {
				if (ptr) // do not increment a null pointer
					ptr++;
				while (ptr == localEnd && currentPage) // if we are at the end of a page then increment to the next non-empty page
					incr_nonInline();
				}
				
			void incr_nonInline() {
				currentPage = (P*) currentPage->ph.next;
				if (currentPage) {
					ptr = pageQueueImpl::pagePtr(currentPage);
					localEnd = &ptr[currentPage->ph.localSize];
					}
				else {
					ptr = NULL;
					localEnd = NULL;
					}
				}
				
			inline typename pageQueueImpl<T,P>::iterator& operator++() {
				incr();
				return *this;
				}
				
			inline bool operator!=(const iterator & other) const { return ptr != other.ptr; }
			inline T operator* () { return *ptr; }
			};
		
		//////////////////////////////////////////////////////////////////////////
		inline pageQueueImpl () : head(NULL), tail(NULL) {}
		~pageQueueImpl() { clear(); }
		
		// pageQueues cannot be copied, only moved
		// move assign and move construct are needed for std::swap auto implementation
		inline void move_impl(STT_PAGEQUEUE_MVSEM other) { head = other.head; tail = other.tail; other.head = NULL; other.tail = NULL; }
		inline pageQueueImpl(STT_PAGEQUEUE_MVSEM other) { move_impl(std::move(other)); }
		inline pageQueueImpl<T,P>& operator= (STT_PAGEQUEUE_MVSEM other) { clear(); move_impl(std::move(other)); return *this; }
		STT_PAGEQUEUE_NOCOPY(pageQueueImpl)
		
		// Allocators/deallocators go here
		static P* allocPage () {
			P* p = ThreadSafePageAllocatorTemplates::allocGeneric<P>();
			p->initHeader();
			return p;
			}
		static void freePage(P* page) {
			ThreadSafePageAllocatorTemplates::freeGeneric<P>(page);
			}
		static void freePagesList(P* pageList) {
			ThreadSafePageAllocatorTemplates::freeGenericList<P>(pageList);
			}
		
		static STT_CONSTEXPR__size_t pageLocalCapacity()         { return P::capacity() / sizeof(T);  }
		static STT_CONSTEXPR__T* pagePtr(P* const p)             { return (T*) &p->_data[STT_PAGE_HEADER_SIZE]; }
		static const STT_CONSTEXPR__T* pagePtr(const P* const p) { return (const T*) &p->_data[STT_PAGE_HEADER_SIZE]; }
		
		inline uint32_t size() const { return head ? head->ph.totalSize : 0; }
		
		// std::vector like stuff goes here:
		void clear() {
			if constexpr(std::is_trivially_destructible<T>::value) {
				// we don't need to invoke destructors so we can just throw away the linked list
				if (head) {
					head->ph.cachedWorkingEnd = (pageHeader*) tail;
					freePagesList(head);
					}
				}
			else {
				// we need to itterate through the linked list and destroy every object
				P* w = head;
				while (w) {
					P* t = w;
					w = (P*) w->ph.next;
					for (uint32_t i = 0; i < t.ph.localSize; ++i)
						pagePtr(t)[i].~T();
					freePage(t);
					}
				}
			head = NULL;
			tail = NULL;
			}
			
		void clearKeepingFirstPage() {
			// Clears the pageQueue but keeps the first page
			if (head && head->next) {
				pageQueueImpl tmp;
				tmp.head = head->next;
				tmp.head->ph.cachedWorkingEnd = tail;
				tmp.tail = tail;
				tmp.clear();
				head = NULL;
				tail = head; 
				}
			}
		
		void swap(pageQueueImpl& other) {
			std::swap(head, other.head);
			std::swap(tail, other.tail);
			}
		
		void concatenate(STT_PAGEQUEUE_MVSEM other) {
			// transfers the other queue to the end of this
			if (!other.head)
				return;
			if (tail) {
				tail->ph.next = (pageHeader*) other.head;
				tail = other.tail;
				}
			else {
				head = other.head;
				tail = other.tail;
				}
			other.head = NULL;
			other.tail = NULL;
			}
		
		void extendTailIfRequired() {
			if (!tail) {
				head = allocPage();
				tail = head;
				}
			if (tail->ph.localSize >= pageLocalCapacity()) {
				tail->ph.next = (pageHeader*) allocPage();
				tail = (P*) tail->ph.next;
				}
			}
		
		inline void push_back(const T& t) {
			extendTailIfRequired();
			new (&(pageQueueImpl::pagePtr(tail)[tail->ph.localSize])) T(t);
			tail->ph.localSize++;
			head->ph.totalSize++;
			}
		
		inline void push_back(T__MVSEM t) {
			stt_dbg_log("move semantics!\n");
			extendTailIfRequired();
			new (&(pageQueueImpl::pagePtr(tail)[tail->ph.localSize])) T(std::move(t));
			tail->ph.localSize++;
			head->ph.totalSize++;
			}
			
		iterator begin() {
			iterator it;
			it.init(head);
			return  it;
			}
			
		iterator end() {
			iterator it;
			it.init(NULL);
			return  it;
			}
		
		};
		

	class PageBumpAllocatedStorage {
	public:
		// todo: move to seperate file
		// used for collections of small objects with similar lifetimes. Stores them in a page
		pageU* page; // custom fields being used - totalSize = totalAllocations
		
		PageBumpAllocatedStorage() {
			page = ThreadSafePageAllocator::allocPage();
			page->initHeader();
			}
		
		~PageBumpAllocatedStorage() {
			STT_STL_ASSERT(page->ph.totalSize == 0, ""); //remaning allocations
			ThreadSafePageAllocator::freePage(page);
			page = NULL;
			}
		
		template <typename T>
		inline static STT_CONSTEXPR__uint32_t roundedSizeOf() { return sizeof(T); }
		
		inline bool contains(void* ptr) const {
			uintptr_t pagei = uintptr_t(page);
			uintptr_t ptri = uintptr_t(ptr);
			return (ptri >= pagei) && (pagei < pagei + page->storageSize());
			}
		
		template <typename T>
		T* allocate() {
			T* r = (T*) &(page->ptr()[page->ph.localSize]);
			page->ph.localSize += roundedSizeOf<T>();
			page->ph.totalSize++;
			new (r) T();
			return r;
			}
		
		template <typename T>
		void free(T* t) {
			if (page->ph.localSize == (uintptr_t(t) - uintptr_t(page)) + roundedSizeOf<T>()) {
				page->ph.localSize -= sizeof(T);
				}
			page->ph.totalSize--;
			t->~T();
			}
			
		uint32_t getNumAllocations() const { return page->ph.totalSize; }
		uint32_t getFreeBytes() const { return page->capacity() - page->ph.localSize; }
		};
	}


