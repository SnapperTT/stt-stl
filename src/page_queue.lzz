#hdr
namespace stt {
	template<typename T, typename P>
	struct pageQueueImpl;
	
	template <typename T>
	using pageQueue = pageQueueImpl<T,pageU>;
	}
#end

#src
#end

namespace stt {
	template<typename T, typename P>
	struct pageQueueImpl {
		P* head;
		P* tail;
		
		struct iterator {
			T* ptr;
			T* localEnd;
			P* currentPage;
			uint32_t idx;
			
			void init(P* page) {
				currentPage = page;
				if (currentPage) {
					ptr = pageQueueImpl::pagePtr(currentPage);
					localEnd = &ptr[currentPage->ph.localSize];
					}
				else {
					ptr = NULL;
					localEnd = NULL;
					}
				}
			
			inline typename pageQueueImpl<T,P>::iterator& operator++() {
				if (ptr) // do not increment a null pointer
					ptr++;
				while (ptr == localEnd && currentPage) // if we are at the end of a page then increment to the next non-empty page
					incr_nonInline();
				return *this;
				}
				
			void incr_nonInline() {
				currentPage = (P*) currentPage->ph.next;
				if (currentPage) {
					ptr = pageQueueImpl::pagePtr(currentPage);
					localEnd = &ptr[currentPage->ph.localSize];
					}
				else {
					ptr = NULL;
					localEnd = NULL;
					}
				}
				
			inline bool operator!=(const iterator & other) const { return ptr != other.ptr; }
			inline T operator* () { return *ptr; }
			};
		
		inline pageQueueImpl () : head(NULL), tail(NULL) {}
		~pageQueueImpl() {
			clear();
			}
		
		// Allocators/deallocators go here
		static P* allocPage () {
			P* p = ThreadSafePageAllocatorTemplates::allocGeneric<P>();
			p->initHeader();
			return p;
			}
		static void freePage(P* page) {
			ThreadSafePageAllocatorTemplates::freeGeneric<P>(page);
			}
		static void freePagesList(P* pageList) {
			ThreadSafePageAllocatorTemplates::freeGenericList<P>(pageList);
			}
		
		static STT_CONSTEXPR__size_t pageLocalCapacity()         { return P::capacity() / sizeof(T);  }
		static STT_CONSTEXPR__T* pagePtr(P* const p)             { return (T*) &p->_data[STT_PAGE_HEADER_SIZE]; }
		static const STT_CONSTEXPR__T* pagePtr(const P* const p) { return (const T*) &p->_data[STT_PAGE_HEADER_SIZE]; }
		
		// std::vector like stuff goes here:
		void clear() {
			if constexpr(std::is_trivially_destructible<T>::value) {
				head->ph.cachedWorkingEnd = (pageHeader*) tail;
				freePagesList(head);
				}
			else {
				P* w = head;
				while (w) {
					P* t = w;
					w = (P*) w->ph.next;
					for (uint32_t i = 0; i < t.ph.localSize; ++i)
						pagePtr(t)[i].~T();
					freePage(t);
					}
				}
			head = NULL;
			tail = NULL;
			}
		
		void extendTailIfRequired() {
			if (!tail) {
				head = allocPage();
				tail = head;
				}
			if (tail->ph.localSize >= pageLocalCapacity()) {
				tail->ph.next = (pageHeader*) allocPage();
				tail = (P*) tail->ph.next;
				}
			}
		
		inline void push_back(const T& t) {
			extendTailIfRequired();
			new (&(pageQueueImpl::pagePtr(tail)[tail->ph.localSize])) T(t);
			tail->ph.localSize++;
			head->ph.totalSize++;
			}
		
		inline void push_back(T__MVSEM t) {
			printf("move semantics!\n");
			extendTailIfRequired();
			new (&(pageQueueImpl::pagePtr(tail)[tail->ph.localSize])) T(std::move(t));
			tail->ph.localSize++;
			head->ph.totalSize++;
			}
			
		iterator begin() {
			iterator it;
			it.init(head);
			return  it;
			}
			
		iterator end() {
			iterator it;
			it.init(NULL);
			return  it;
			}
		
		};
	}
