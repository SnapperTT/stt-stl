#hdr
#ifndef STT_PAGE_HEADER_SIZE
	#define STT_PAGE_HEADER_SIZE 64
#endif
#ifndef STT_PAGE_SIZE
	#define STT_PAGE_SIZE 4080	// this makes alignement better 
#endif
#ifndef STT_JUMBO_PAGE_SIZE
	#define STT_JUMBO_PAGE_SIZE 65520	// 64k - 64
#endif
#ifndef STT_MEGA_PAGE_SIZE
	#define STT_MEGA_PAGE_SIZE 2097088	// 2MB - 64
#endif

	
#end

#src

namespace stt {
	static_assert(sizeof(pageHeader) <= STT_PAGE_HEADER_SIZE);
	}
#end

// A page is a fixed size block of memory
// the idea is that pages are allocated once then recycled

namespace stt {
	enum pageTypeEnum {
		PAGE_TYPE_NORMAL,
		PAGE_TYPE_JUMBO,
		PAGE_TYPE_MEGA,
		PAGE_TYPE_UNSET
		};
		
	const char * pageTypeEnumToString(const pageTypeEnum pt) {
		switch (pt) {
			case pageTypeEnum::PAGE_TYPE_NORMAL: return "Normal";
			case pageTypeEnum::PAGE_TYPE_JUMBO: return "Jumbo";
			case pageTypeEnum::PAGE_TYPE_MEGA: return "Jumbo";
			default: return "Unset";
			}
		}
	
	struct pageHeader {
		// note: not all fields are used!
		//void* allocator;			  // (unused) what object controls the lifetime of this? If NULL then it is assumed that the global ThreadSafePageAllocatorImpl handles this
		pageHeader* next;			  // next page
		pageHeader* cachedWorkingEnd; // (optional) if this is the head of a linked list then this is the end page, otherwise this is undefiend
		
		uint64_t allocationInfo;	  //
		uint32_t localSize;			  // (optional) if this page is an array then this is the local size of the array
		uint32_t totalSize;			  // (optional) if this is the head of a linked list of arrays then this is the running total
		uint64_t userData[4];		  // general purpose memory

		
		inline void initToZero() {
			//allocator = NULL;
			next = NULL;
			cachedWorkingEnd = NULL;
			allocationInfo = 0;
			localSize = 0;
			totalSize = 0;
			userData[0] = 0;
			userData[1] = 0;
			userData[2] = 0;
			userData[3] = 0;
			}
		
		
		void appendList(pageHeader* other) {
			// appends other to this list
			// assumes cachedWorkingEnd is a valid value for both this and othe
			// assumes other is not null
			cachedWorkingEnd->next = other;
			cachedWorkingEnd = other->cachedWorkingEnd;
			}
			
		pageHeader* splitList(const uint32_t nPages) {
			// assumes cachedWorkingEnd is a valid value for this
			// if this is too short then returns NULL
			pageHeader* w = this;
			uint32_t cnt = 1;
			while (w->next && (cnt < nPages)) {
				cnt++;
				w = w->next;
				}
			// w should now be the end of this list
			// and w->next should be the start of next
			if (!w) return NULL; // fail split
			if (!w->next) return NULL; // fail split
			
			pageHeader* r = w->next;
			r->cachedWorkingEnd = cachedWorkingEnd;
			w->next = NULL;
			cachedWorkingEnd = w;
			return r;
			}
		
		static pageHeader* buildList(pageHeader** pages, const uint32_t nPages) {
			// assembles pages into a linked list, returns the head
			if (!nPages) return NULL;
			for (uint32_t i = 0; i < nPages-1; ++i) {
				pages[i]->next = pages[i+1];
				}
			pages[nPages-1]->next = NULL;
			pages[0]->cachedWorkingEnd = pages[nPages-1];
			return pages[0];
			}
		
		pageHeader* end() {
			// manually traverses to the end
			pageHeader* w = this;
			while (w->next) { w = w->next; }
			return w;
			}
			
		pageHeader* endCounting(int& countOut) {
			// manually traverses to the end, counts number of pages
			pageHeader* w = this;
			countOut++;
			while (w->next) { w = w->next; countOut++; }
			return w;
			}
			
		pageHeader* endCountingDumping(int& countOut) {
			pageHeader* w = this;
			countOut++;
			while (w->next) {
				w = w->next;
				#ifdef STT_STL_DEBUG
				stt_dbg_log("\t\tendCountingDumping %p %i deep is %p\n", this, countOut, w);
				#endif
				countOut++; 
				}
			return w;
			}
			
		int listLength() {
			int cnt = 0;
			endCounting(cnt);
			return cnt;
			}
			
		inline uint8_t* toPayload() {
			uint8_t* ptr = (uint8_t*) this;
			return ptr + STT_PAGE_HEADER_SIZE;
			}
		
		inline static pageHeader* fromPayload(uint8_t* ptr) {
			// Reverse operation of pageU::ptr(), takes a page's data pointer and returns the address of the header
			return (pageHeader*) (ptr - STT_PAGE_HEADER_SIZE);
			}
		
		////////////////////////////////////////////////////////////////
		// bitmap allocator stuff
		
		inline bool bit_test(const uint32_t index) const {
			// When userdata is used as a bitmap for the data
			// this returns if bit index 
			return (userData[index >> 6] >> (index & 63)) & 1ULL;
			}

		inline void bit_set(const uint32_t index) {
			userData[index >> 6] |= (1ULL << (index & 63));
			}

		inline void bit_clear(const uint32_t i) {
			userData[i >> 6] &= ~(1ULL << (i & 63));
			}
		
		int bit_get_first_free_slot() const {
			for (int i = 0; i < 4; ++i) {
				int r = stt::find_first_set_bit_u64(userData[i]);
				if (r >= 0)
					return r + i*64;
				}
			return -1;
			}
			
		uint8_t* bitmap_allocate_impl(uint8_t* base, const uint32_t blockSize, const uint32_t maxSlots) {
			uint32_t freeSlotIdx = bit_get_first_free_slot();
			if (freeSlotIdx >= maxSlots) return NULL; // silent fail alloc
			if (bit_test(freeSlotIdx)) {
				stt::error::bad_alloc(blockSize, "double alloc (internal bug)"); // should never be reached
				return NULL;
				}
			bit_set(freeSlotIdx);
			return &base[blockSize*freeSlotIdx];
			}
			
		void bitmap_free_impl(uint8_t* ptr, uint8_t* base, const uint32_t blockSize, const uint32_t maxSlots) {
			uint32_t slotIdx = (ptr - base)/blockSize;
			if (slotIdx >= maxSlots) {
				stt::error::bad_free(ptr, "free out of bounds");
				return; // out of bounds
				}
			if (!bit_test(slotIdx)) {
				stt::error::bad_free(ptr, "double free");
				return; // double free
				}
			bit_clear(slotIdx);
			}
		}
		
	
	template<unsigned int SIZE, pageTypeEnum ET>
	union pageTemplate {
		pageHeader ph;
		uint8_t _data[SIZE];
		
		inline void initHeader() { ph.initToZero(); ph.allocationInfo = SIZE; }
		STT_CONSTEXPR__uint8_t* ptr()             { return &_data[STT_PAGE_HEADER_SIZE]; }
		const STT_CONSTEXPR__uint8_t* ptr() const { return &_data[STT_PAGE_HEADER_SIZE]; }
		static STT_CONSTEXPR__size_t capacity() { return SIZE - STT_PAGE_HEADER_SIZE;  }
		static STT_CONSTEXPR__size_t storageSize() { return SIZE;  }
		static STT_CONSTEXPR__pageTypeEnum getPageType() { return ET; }
			
		template <int BLOCK_SIZE>
		uint8_t* bitmap_allocate() {
			constexpr uint32_t maxSlots = capacity()/BLOCK_SIZE;
			return ph.bitmap_allocate_impl(ptr(), BLOCK_SIZE, maxSlots < 256 ? maxSlots : 256);
			}
			
		template <int BLOCK_SIZE>
		void bitmap_free(const uint8_t* m_ptr, const uint32_t blockSize) {
			constexpr uint32_t maxSlots = capacity()/BLOCK_SIZE;
			return ph.bitmap_free_impl(m_ptr, ptr(), BLOCK_SIZE, maxSlots < 256 ? maxSlots : 256);
			}
			
		inline bool bitmap_contains(const uint8_t* m_ptr) const {
			uintptr_t p = ptr();
			uintptr_t m = m_ptr;
			return (m >= p) && (m < p + capacity());
			}
		};
	
	typedef pageTemplate<STT_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_NORMAL> pageU;
	typedef pageTemplate<STT_JUMBO_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_JUMBO> jumboPageU;
	typedef pageTemplate<STT_MEGA_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_MEGA> megaPageU;
		
	
	//template <unsigned int USZ>
	//union unboundedPageI {
	//	pageHeader ph;
	//	uint8_t _data[USZ];
	//	
	//	STT_CONSTEXPR__void* ptr()             { return &_data[STT_PAGE_HEADER_SIZE]; }
	//	const STT_CONSTEXPR__void* ptr() const { return &_data[STT_PAGE_HEADER_SIZE]; }
	//	static STT_CONSTEXPR__size_t capacity() { return STT_PAGE_SIZE - STT_PAGE_HEADER_SIZE;  }
	//	};

	}
