#hdr

namespace stt {
struct msaSilentFailErrorHandler {
	static void throw_max_size_error(void* _ptr) {}
	};
	
struct msaAbortErrorHandler {
	static void throw_max_size_error(void* _ptr) { STT_STL_ABORT(); }
	};
	
template <typename T, uint32_t MAX_ELEMENTS, typename SIZE_TYPE = uint8_t, typename ErrorHandler = stt::msaAbortErrorHandler>
class maxSizeArray {
public:
	// Purpose: drop in replacement for std::vector where you know the
	// size of the vector will not exceed a fixed size
	//
	using iterator       = T*;
	using const_iterator = const T*;
	using size_type = storage_size_t;
	using reference      = T&;
	using const_reference = const T&;
	using reverse_iterator = stt::reverse_iterator<iterator>;
	using const_reverse_iterator = stt::reverse_iterator<const_iterator>;
	typedef T value_type;
		
	uint8_t buff[MAX_ELEMENTS*sizeof(T)];
	SIZE_TYPE mSize;
	
	static_assert(SIZE_TYPE(-1) >= MAX_ELEMENTS);
	
	inline T* data() { return (T*) &buff[0]; }
	inline const T* data() const { return (T*) &buff[0]; }
	
	inline T& operator [] (const uint32_t idx) { return data()[idx]; }
	inline const T& operator [] (const uint32_t idx) const { return data()[idx]; }
	inline T& at(const uint32_t idx) { return data()[idx]; }
	inline const T& at(const uint32_t idx) const { return data()[idx]; }
	
	// get - returns a pointer to the object at (idx). Useful for lua bindings of arrays of objects without copying
	inline T* get(const uint32_t idx) { return &(data()[idx]); }
	inline const T* getC(const uint32_t idx) const { return &(data()[idx]); }
		
	inline uint64_t size_bytes() const noexcept { return mSize*sizeof(T); }
	inline storage_size_t size() const noexcept { return mSize; }
	inline storage_size_t length() const noexcept   { return mSize; }
	inline static STT_CONSTEXPR__storage_size_t capacity() { return MAX_ELEMENTS; }
	inline static STT_CONSTEXPR__storage_size_t max_size() { return MAX_ELEMENTS; }
	
	inline const_iterator cbegin() const noexcept { return const_iterator(data()); }
	inline const_iterator cend()   const noexcept { return const_iterator(data() + size()); };
	inline const_iterator begin() const noexcept { return const_iterator(data()); }
	inline const_iterator end()   const noexcept { return const_iterator(data() + size()); };
	inline iterator begin() noexcept { return iterator(data()); }
	inline iterator end()   noexcept { return iterator(data() + size()); }
	
	inline reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
	inline reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
	inline const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }
	inline const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }
	inline const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
	inline const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }
		
	inline bool empty() const { return !mSize; }
	
	inline T& front()             { return data()[0]; }
	inline const T& front() const { return data()[0]; }
	inline T& back()             { return data()[size()-1]; }
	inline const T& back() const { return data()[size()-1]; }
	
	
	inline void clear() {
		if constexpr (requires_destroy_on_resize<T>::value)
			objectDestroyRange(data(), data() + mSize); 
		mSize = 0;
		}
	
	inline void resize(const uint32_t sz) {
		if (sz > MAX_ELEMENTS) {
			if constexpr (requires_fill_on_resize<T>::value)
				objectFillRangeInPlace(data() + mSize, data() + MAX_ELEMENTS);
			mSize = MAX_ELEMENTS;
			return ErrorHandler::throw_max_size_error(this);
			}
			
		if constexpr (requires_fill_on_resize<T>::value)
			if (sz > mSize)
				objectFillRangeInPlace(data() + mSize, data() + sz);
		
		if constexpr (requires_destroy_on_resize<T>::value)
			if (sz < mSize)
				objectDestroyRange(data() + sz, data() + mSize);
		
		mSize = sz;
		}
	
	inline void reserve(const uint32_t sz) {
		if (sz > MAX_ELEMENTS)
			return ErrorHandler::throw_max_size_error(this);
		}
		
	inline void pop_back() {
		const storage_size_t sz = size();
		if (sz)
			resize(sz-1);
		}
		
	inline void push_back(const T & a) {
		if (mSize >= MAX_ELEMENTS) return ErrorHandler::throw_max_size_error(this);
		data()[mSize] = a;
		mSize++;
		}
		
	inline void push_back(T__MVSEM a) {
		if (mSize >= MAX_ELEMENTS) return ErrorHandler::throw_max_size_error(this);
		new (data() + mSize) T(std::move(a)); // move construct in place
		mSize++;
		}
	
	// alias of push_back for lua binding
	inline void push_back_luasafe(const T & a) { push_back(a); }
	
	inline maxSizeArray() : mSize(0) {}
		
	inline ~maxSizeArray() {
		clear();
		}
	
	};
}

#end

#src
#end
