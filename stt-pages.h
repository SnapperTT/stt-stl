// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// mt_page_allocator_impl.hh
//

#ifndef LZZ_mt_page_allocator_impl_hh
#define LZZ_mt_page_allocator_impl_hh

#ifndef STT_TLS_WRAPPER
	#ifdef __WIN32
		#define STT_TLS_WRAPPER WindowsThreadLocalWrapper
		#define STT_WINDOWS_TLS 1
		#define STT_thread_local_PATL_Data int
		#define STT_DWORD DWORD
	#else
		#define STT_TLS_WRAPPER NativeThreadLocalWrapper
	#endif
#endif
#ifndef STT_thread_local_PATL_Data
	#define STT_thread_local_PATL_Data thread_local PATL_Data
#endif
#ifndef STT_DWORD
	#define STT_DWORD int
#endif

namespace stt {
	struct PATL_Data;
	}
	
#include <mutex>
#include <atomic>
#ifdef STT_DEBUG_PAGE
	#include <thread>
#endif
#define LZZ_INLINE inline
namespace stt
{
  struct PATL_Data;
}
namespace stt
{
  struct NativeThreadLocalWrapper
  {
    static STT_thread_local_PATL_Data * mData;
    PATL_Data * getTlsData ();
    void setTlsData (PATL_Data * ptr);
  };
}
namespace stt
{
  struct WindowsThreadLocalWrapper
  {
    STT_DWORD dwTlsIndex;
    WindowsThreadLocalWrapper ();
    ~ WindowsThreadLocalWrapper ();
    PATL_Data * getTlsData ();
    void setTlsData (PATL_Data * ptr);
  };
}
namespace stt
{
  class BackendPagePool;
}
namespace stt
{
  class ThreadLocalPagePool;
}
namespace stt
{
  class BackendPagePool
  {
  public:
    pageTypeEnum mPageType;
    uint32_t batchSize;
    pageHeader * allocFreeList;
    std::mutex mMutex;
    std::atomic <pageHeader*> _list;
    BackendPagePool ();
    ~ BackendPagePool ();
    void dbg_print_status ();
    void freeAll ();
    void freePages (pageHeader * * pages, uint32_t const nPages);
    void atomicMerge (pageHeader * _insert, uint32_t const _nReturned);
    void atomicMerge (pageHeader * _insert);
    pageHeader * atomicTake ();
    void bulkFetch (pageHeader * * store, uint32_t const nPages);
  };
}
namespace stt
{
  class PassthroughPageAllocator
  {
  public:
    static void allocGeneric (pageTypeEnum const pageType, pageHeader * * pages, uint32_t const nPages);
    template <typename T>
    static void allocGeneric (pageHeader * * pages, uint32_t const nPages);
    static void freeGeneric (pageHeader * * pages, uint32_t const nPages);
    static void freeGenericList (pageHeader * pagesLinkedList);
  };
}
namespace stt
{
  class ThreadLocalPagePool
  {
  public:
    pageHeader * freelist;
    pageTypeEnum mPageType;
    int nPagesInFreeList;
    int requestAmount;
    int maxFreeListAmount;
    int threadId;
    char (snstt_dbg_logBuffer) [64];
    static std::atomic <int> staticNextId;
    ThreadLocalPagePool ();
    void init (pageTypeEnum const _pageType, uint32_t const _threadId);
    ~ ThreadLocalPagePool ();
    char const * getThreadLabel ();
    void dbg_print_status ();
    void dbg_dump_freelist ();
    void dbgMarkPageAllocated (pageHeader * page);
    void dbgMarkPageFreed (pageHeader * page);
    void dbgMarkPageFreedList (pageHeader * pagesLinkedList);
    void allocPages (pageHeader * * pages, uint32_t const nPages);
    void freePages (pageHeader * * pages, uint32_t const nPages);
    void freePagesList (pageHeader * pagesLinkedList, uint32_t const knownCount = 0);
    void returnPagesToGlobalPool (pageHeader * returnList, uint32_t const nReturned);
  };
}
namespace stt
{
  struct PATL_Data
  {
    ThreadLocalPagePool pageAlloc;
    ThreadLocalPagePool jumboPageAlloc;
    PATL_Data ();
    ~ PATL_Data ();
  };
}
namespace stt
{
  class ThreadSafePageAllocatorImpl
  {
  public:
    STT_TLS_WRAPPER mTls;
    BackendPagePool PageGlobalFreeList;
    BackendPagePool JumboGlobalFreeList;
    ThreadSafePageAllocatorImpl ();
    ~ ThreadSafePageAllocatorImpl ();
    static uint8_t * raw_alloc (uint64_t const sz);
    static void raw_free (uint8_t * ptr, uint64_t const sz);
    static ThreadSafePageAllocatorImpl & get ();
    void perf_warning (char const * msg);
    void initThreadLocalAllocators ();
    void cleanupThreadLocalAllocators ();
    void cleanupGlobalFreeLists ();
    PATL_Data * getThreadLocalAllocators ();
    void allocPages (pageU * * pages, uint32_t const nPages);
    void freePages (pageU * * pages, uint32_t const nPages);
    void freePagesList (pageU * pageList);
    void allocJumboPages (pageU * * pages, uint32_t const nPages);
    void freeJumboPages (pageU * * pages, uint32_t const nPages);
    static void systemAllocate (pageTypeEnum const mPageType, uint32_t const nPagesTotal, uint32_t const nSplit, pageHeader * * groupA, pageHeader * * groupB);
    template <typename PAGE_TYPE>
    static void systemAllocate_impl (uint32_t const nPagesTotal, uint32_t const nSplit, pageHeader * * groupA, pageHeader * * groupB);
    static void systemFreeList (pageHeader * head);
  };
}
namespace stt
{
  LZZ_INLINE PATL_Data * NativeThreadLocalWrapper::getTlsData ()
                                       { return mData; }
}
namespace stt
{
  LZZ_INLINE void NativeThreadLocalWrapper::setTlsData (PATL_Data * ptr)
                                               { mData = ptr; }
}
namespace stt
{
  LZZ_INLINE PATL_Data * WindowsThreadLocalWrapper::getTlsData ()
                                       {
		#ifdef STT_WINDOWS_TLS
		return (PATL_Data*) TlsGetValue(dwTlsIndex);
		#else
		return NULL;
		#endif
		}
}
namespace stt
{
  LZZ_INLINE void WindowsThreadLocalWrapper::setTlsData (PATL_Data * ptr)
                                               {
		#ifdef STT_WINDOWS_TLS
		TlsSetValue(dwTlsIndex, ptr);
		#endif
		}
}
namespace stt
{
  LZZ_INLINE void BackendPagePool::atomicMerge (pageHeader * _insert, uint32_t const _nReturned)
                                                                                {
		#ifdef STT_DEBUG_PAGE
		stt_dbg_log("BackendPagePool atomicMerge: %p %i\n", _insert, _nReturned);
		#endif
		atomicMerge(_insert);
		}
}
namespace stt
{
  template <typename T>
  void PassthroughPageAllocator::allocGeneric (pageHeader * * pages, uint32_t const nPages)
                                                                            {
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
			for (uint32_t i = 0; i < nPages; ++i)
				pages[i] = (pageHeader*) new T;
		#endif
		}
}
namespace stt
{
  LZZ_INLINE void ThreadLocalPagePool::dbgMarkPageAllocated (pageHeader * page)
                                                           {
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("ThreadLocalPagePool %s: Allocationg page %p\n", getThreadLabel(), page);
		#endif
		}
}
namespace stt
{
  LZZ_INLINE void ThreadLocalPagePool::dbgMarkPageFreed (pageHeader * page)
                                                       {
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("ThreadLocalPagePool %s: Freeing page %p\n", getThreadLabel(), page);
		#endif
		}
}
namespace stt
{
  LZZ_INLINE void ThreadLocalPagePool::dbgMarkPageFreedList (pageHeader * pagesLinkedList)
                                                                      {
		#ifdef STT_DEBUG_PAGE
			pageHeader* tmp = pagesLinkedList;
			while (tmp) {
				dbgMarkPageFreed(tmp);
				tmp = tmp->next;
				}
		#endif
		}
}
namespace stt
{
  LZZ_INLINE void ThreadSafePageAllocatorImpl::perf_warning (char const * msg)
                                                   {
		stt_dbg_log("stt::ThreadSafePageAllocator WARNING: %s\n", msg);
		}
}
namespace stt
{
  template <typename PAGE_TYPE>
  void ThreadSafePageAllocatorImpl::systemAllocate_impl (uint32_t const nPagesTotal, uint32_t const nSplit, pageHeader * * groupA, pageHeader * * groupB)
                                                                                                                                     {
		// Group A & B are pointers to pointers, NOT arrays of pointers
		// allocates at least nPagesTotal, and returns (nSplit) into linked list groupA and the rest into linked list groupB
		
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("Allocating %i (%i) pages\n", nPagesTotal, nSplit);
		#endif
		
		pageHeader* ph[nPagesTotal];
		ph[0] = (pageHeader*) raw_alloc(sizeof(PAGE_TYPE));
		for (uint i = 1; i < nPagesTotal; ++i) {
			ph[i] = (pageHeader*) raw_alloc(sizeof(PAGE_TYPE));
			ph[i-1]->next = ph[i];
			}
		
		// are we splitting?
		if (nSplit > 0) {
			ph[nSplit-1]->next = NULL;
			*groupA = ph[0];
			*groupB = ph[nSplit];
			
			ph[0]->cachedWorkingEnd = ph[nSplit-1];
			ph[nSplit]->cachedWorkingEnd = ph[nPagesTotal-1];
			}
		else {
			*groupA = NULL;
			*groupB = ph[0];
			ph[0]->cachedWorkingEnd = ph[nPagesTotal-1];
			}
		}
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_mt_page_allocator_impl
#define STT_STL_IMPL_DOUBLE_GUARD_mt_page_allocator_impl
#define LZZ_OVERRIDE
// mt_page_allocator_impl.cpp
//

#define LZZ_INLINE inline
namespace stt
{
  STT_thread_local_PATL_Data * NativeThreadLocalWrapper::mData;
}
namespace stt
{
  WindowsThreadLocalWrapper::WindowsThreadLocalWrapper ()
                                    {
		dwTlsIndex = 0;
		#ifdef STT_WINDOWS_TLS
		dwTlsIndex = TlsAlloc();
		if (dwTlsIndex == TLS_OUT_OF_INDEXES)
			STT_STL_ABORT();
		#endif
		}
}
namespace stt
{
  WindowsThreadLocalWrapper::~ WindowsThreadLocalWrapper ()
                                     {
		#ifdef STT_WINDOWS_TLS
		TlsFree(dwTlsIndex);
		#endif
		}
}
namespace stt
{
  BackendPagePool::BackendPagePool ()
                          {
		mPageType = pageTypeEnum::PAGE_TYPE_UNSET;
		batchSize = 100;
		
		allocFreeList = NULL;
		_list = NULL;
		}
}
namespace stt
{
  BackendPagePool::~ BackendPagePool ()
                           {
		#ifdef STT_DEBUG_PAGE
		stt_dbg_log("~BackendPagePool %s\n", pageTypeEnumToString(mPageType));
		dbg_print_status();
		#endif
		freeAll();
		}
}
namespace stt
{
  void BackendPagePool::dbg_print_status ()
                                {
		mMutex.lock();
		pageHeader* h = atomicTake();
		stt_dbg_log("\tBackendPagePool (%s): %p, %i -- %p, %i\n", pageTypeEnumToString(mPageType), allocFreeList, allocFreeList ? allocFreeList->listLength() : 0, h, h ? h->listLength() : 0);
		if (h) atomicMerge(h);
		mMutex.unlock();
		}
}
namespace stt
{
  void BackendPagePool::freeAll ()
                       {
		// Takes all pages held here and deallocates them
		mMutex.lock();
		pageHeader* h = atomicTake();
		#ifdef STT_DEBUG_PAGE
		stt_dbg_log("BackendPagePool freeAll IN: h: %p, allocFreeList: %p\n", h, allocFreeList);
		#endif
		if (h) {
			if (allocFreeList)
				allocFreeList->appendList(h);
			else
				allocFreeList = h;
			}
		#ifdef STT_DEBUG_PAGE
		stt_dbg_log("BackendPagePool freeAll: allocFreeList %p\n", allocFreeList);
		#endif
		ThreadSafePageAllocatorImpl::systemFreeList(allocFreeList);
		allocFreeList = NULL;
		mMutex.unlock();
		}
}
namespace stt
{
  void BackendPagePool::freePages (pageHeader * * pages, uint32_t const nPages)
                                                                  {
		// For the situation where we have an array of pages
		if (!nPages) return;
		atomicMerge(pageHeader::buildList(pages, nPages), nPages);
		}
}
namespace stt
{
  void BackendPagePool::atomicMerge (pageHeader * _insert)
                                              {
		// Adds @_insert to the atomic free list @this->_list
		
		// Remove head from atomic to working memory
		pageHeader* workingList = atomicTake();
		// _list is now NULL
		
		// merge the lists
		if (workingList)
			_insert->appendList(workingList);
		workingList = _insert;
		
		// replace NULL head with the working list
		pageHeader* nullList = NULL;
		if (!_list.compare_exchange_strong(nullList, workingList)) {
			// failed merge, this must have been due to pre-emption, re-merge
			atomicMerge(workingList);
			}
		}
}
namespace stt
{
  pageHeader * BackendPagePool::atomicTake ()
                                  {
		// Reads the value of @_list and replaces it with NULL
		pageHeader* workingList = _list.load();
		while (!_list.compare_exchange_weak(workingList, NULL));
		return workingList; 
		}
}
namespace stt
{
  void BackendPagePool::bulkFetch (pageHeader * * store, uint32_t const nPages)
                                                                  {
		// Yank off atomic list and merge the linked lists
		if (!nPages) return;
		pageHeader* h = atomicTake();
		mMutex.lock();
		if (h) {
			if (allocFreeList)
				allocFreeList->appendList(h);
			else
				allocFreeList = h;
			}
		
		pageHeader* w = allocFreeList;
		uint32_t i = 0;
		if (w) {
			for (i = 0; i < nPages && w->next; ++i) {
				store[i] = w;
				w = w->next;
				}
			}
			
		const uint32_t nAllocated = i;
		if (i == nPages) {
			// cut the linked list here
			pageHeader* newHead = w->next;
			w->next = NULL;
			w->cachedWorkingEnd = NULL;
			if (newHead)
				newHead->cachedWorkingEnd = allocFreeList->cachedWorkingEnd;
			allocFreeList = newHead;
			mMutex.unlock();
			
			store[nPages-1]->next = NULL;
			
			
			#if STT_DEBUG_PAGE
				stt_dbg_log ("bulkFetch out path a, %i pages allocated\n", i);
			#endif
			return;
			}
		
		// we have a parital linked list, we need system allocation
		pageHeader* remaining = NULL;
		pageHeader* leftovers = NULL;
		ThreadSafePageAllocatorImpl::systemAllocate(mPageType, batchSize + nPages - nAllocated, nPages - nAllocated, &remaining, &leftovers);
		
		for (; i < nPages; ++i) {
			store[i] = remaining;
			remaining = remaining->next;
			}
		
		// the entire free list has been consumed so we can dispose of it here
		allocFreeList = leftovers;
		
		#if STT_DEBUG_PAGE
		stt_dbg_log ("bulkFetch %s, %i, %i\n", pageTypeEnumToString(mPageType), batchSize + nPages - nAllocated, nPages - nAllocated);
		int cnt = 0;
		pageHeader* tail = allocFreeList;
		stt_dbg_log ("allocFreeList %p %p %p %p %i\n", allocFreeList, allocFreeList->next, allocFreeList->cachedWorkingEnd, tail, cnt);
		#endif
		
		mMutex.unlock();
		}
}
namespace stt
{
  void PassthroughPageAllocator::allocGeneric (pageTypeEnum const pageType, pageHeader * * pages, uint32_t const nPages)
                                                                                                         {
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
		if (pageType == pageTypeEnum::PAGE_TYPE_NORMAL) 
			return allocGeneric<pageU>(pages, nPages);
		else if (pageType == pageTypeEnum::PAGE_TYPE_JUMBO) 
			return allocGeneric<jumboPageU>(pages, nPages);
		else
			STT_STL_ABORT();
		#endif
		}
}
namespace stt
{
  void PassthroughPageAllocator::freeGeneric (pageHeader * * pages, uint32_t const nPages)
                                                                           {
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
			for (uint32_t i = 0; i < nPages; ++i)
				delete pages[i];
		#endif
		}
}
namespace stt
{
  void PassthroughPageAllocator::freeGenericList (pageHeader * pagesLinkedList)
                                                                 {
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
			pageHeader* tmp = pagesLinkedList;
			while (tmp) {
				pageHeader* d = tmp;
				tmp = tmp->next;
				delete d;
				}
		#endif
		}
}
namespace stt
{
  std::atomic <int> ThreadLocalPagePool::staticNextId = 0;
}
namespace stt
{
  ThreadLocalPagePool::ThreadLocalPagePool ()
                              {}
}
namespace stt
{
  void ThreadLocalPagePool::init (pageTypeEnum const _pageType, uint32_t const _threadId)
                                                                           {
		mPageType = _pageType;
		freelist = NULL;
		nPagesInFreeList = 0;
		
		requestAmount = 10;
		maxFreeListAmount = 20;
		
		threadId = _threadId;
		stt_memset((uint8_t*) &snstt_dbg_logBuffer[0], 0, 64);
		
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("INIT NEW ThreadLocalPagePool %s\n", getThreadLabel());
		#endif
		}
}
namespace stt
{
  ThreadLocalPagePool::~ ThreadLocalPagePool ()
                               {
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("~ThreadLocalPagePool %s\n", getThreadLabel());
			dbg_print_status();
		#endif
		returnPagesToGlobalPool(freelist, nPagesInFreeList);
		freelist = NULL;
		}
}
namespace stt
{
  char const * ThreadLocalPagePool::getThreadLabel ()
                                      {
		#ifdef STT_DEBUG_PAGE_THREAD_LABEL
			return STT_DEBUG_PAGE_THREAD_LABEL(this);
		#else
			#ifdef STT_DEBUG_PAGE
				snprintf(snstt_dbg_logBuffer, 64, "[T%i %x %p]", threadId, (unsigned int) std::hash<std::thread::id>()(std::this_thread::get_id()), this);
				return snstt_dbg_logBuffer;
			#endif
		#endif
		return NULL;
		}
}
namespace stt
{
  void ThreadLocalPagePool::dbg_print_status ()
                                {
		#ifdef STT_DEBUG_PAGE
			int fll = freelist ? freelist->listLength() : 0;
			stt_dbg_log("\tThreadLocalPagePool (%s, %s): %p -> %p, %i/%i\n", pageTypeEnumToString(mPageType), getThreadLabel(), freelist, freelist ? freelist->cachedWorkingEnd : NULL, fll, nPagesInFreeList);
			if (fll != nPagesInFreeList)
				dbg_dump_freelist();
			STT_STL_ASSERT (fll == nPagesInFreeList, "freelist is corrupt (1)");
		#endif
		}
}
namespace stt
{
  void ThreadLocalPagePool::dbg_dump_freelist ()
                                 {
		#ifdef STT_DEBUG_PAGE
			int i = 0;
			pageHeader* tmp = freelist;
			while (tmp) {
				stt_dbg_log("\tThreadLocalPagePool %s: Freelist %i: %p\n", getThreadLabel(), i, tmp);
				tmp = tmp->next;
				i++;
				}
			stt_dbg_log("\tThreadLocalPagePool %s: nPagesInFreeList %i, count: %i\n", getThreadLabel(), nPagesInFreeList, i);
			STT_STL_ASSERT (i == nPagesInFreeList, "freelist is corrupt (2)");
		#endif
		}
}
namespace stt
{
  void ThreadLocalPagePool::allocPages (pageHeader * * pages, uint32_t const nPages)
                                                                   {
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
			return PassthroughPageAllocator::allocGeneric(mPageType, pages, nPages);
		#endif
		#ifdef STT_DEBUG_PAGE
				stt_dbg_log("ThreadLocalPagePool %s allocPages: nPages: %i, freelist length: %i, nPagesInFreeList %i -> %i \n", getThreadLabel(), nPages, freelist ? freelist->listLength() : 0, nPagesInFreeList, nPagesInFreeList - nPages);
		#endif
			
		uint32_t count = 0;
		if (freelist) {
			pageHeader* workingEnd = freelist->cachedWorkingEnd;
			while (freelist && count < nPages) {
				pages[count] = freelist;
				dbgMarkPageAllocated(pages[count]);
				count++;
				freelist = freelist->next;
				}
			if (freelist)
				freelist->cachedWorkingEnd = workingEnd;
			}
		if (count == nPages) {
			nPagesInFreeList -= count;
			return;
			}
		if (count < nPages) {
			// we are out of pages, request pages from TSPA (locking)
			const uint32_t countInit = count;
			const uint32_t want = requestAmount + nPages - count;	// Batch size + (num needed for this request)
			pageHeader* localStore[want];
			
			#ifdef STT_DEBUG_PAGE
				stt_dbg_log("ThreadLocalPagePool %s fetching from backend want: %i, nPages: %i, count: %i, (nPages - countInit): %i, requestAmount: %i\n", getThreadLabel(), want, nPages, count, (nPages-countInit), requestAmount);
			#endif
			
			if (mPageType == pageTypeEnum::PAGE_TYPE_NORMAL)
				ThreadSafePageAllocatorImpl::get().PageGlobalFreeList.bulkFetch(&localStore[0], want);
			else if (mPageType == pageTypeEnum::PAGE_TYPE_JUMBO)
				ThreadSafePageAllocatorImpl::get().JumboGlobalFreeList.bulkFetch(&localStore[0], want);
			else
				STT_STL_ABORT();
			
			#ifdef STT_DEBUG_PAGE
			stt_dbg_log("ThreadLocalPagePool %s S0 localStore:\n", getThreadLabel());
			for (uint32_t i = 0; i < want; ++i) {
				stt_dbg_log("\t%i: %p", i, localStore[i]);
				}
				stt_dbg_log("\n");
			#endif
			
			uint32_t idx = 0;
			for (;count < nPages; ++count) {
				pages[count] = localStore[idx];
				dbgMarkPageAllocated(pages[count]);
				++idx;
				}
					
			#ifdef STT_DEBUG_PAGE
			stt_dbg_log("ThreadLocalPagePool %s S1 allocPages:\n", getThreadLabel());
				STT_STL_ASSERT(freelist == NULL, "freelist is null");
			#endif
			freelist = localStore[nPages - countInit];
			freelist->cachedWorkingEnd = localStore[want-1];
			nPagesInFreeList = requestAmount;
			
			#ifdef STT_DEBUG_PAGE
			stt_dbg_log("ThreadLocalPagePool %s S2 allocPages:\n", getThreadLabel());
				dbg_print_status();
			#endif
			}
		}
}
namespace stt
{
  void ThreadLocalPagePool::freePages (pageHeader * * pages, uint32_t const nPages)
                                                                  {
		// assembles pages into a linked list, then adds to the freelist
		if (!nPages) return;
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
			return PassthroughPageAllocator::freeGeneric(pages, nPages);
		#endif
		freePagesList(pageHeader::buildList(pages, nPages), nPages);
		}
}
namespace stt
{
  void ThreadLocalPagePool::freePagesList (pageHeader * pagesLinkedList, uint32_t const knownCount)
                                                                                       {
		// frees an already prepared linked list of pages
		// if the number of pages is not known then knownCount 
		#ifdef STT_PASSTHROUGH_TL_PAGE_ALLOCATOR
			return PassthroughPageAllocator::freeGenericList(pagesLinkedList);
		#endif
		dbg_dump_freelist();
		
		uint32_t realKnownCount = knownCount;
		if (!realKnownCount) {
			pageHeader* tmp = pagesLinkedList;
			while (tmp) {
				tmp = tmp->next;
				realKnownCount++;
				}
			}
		dbgMarkPageFreedList(pagesLinkedList);
			
		nPagesInFreeList += realKnownCount;	
		
		if (freelist)
			pagesLinkedList->appendList(freelist);
		freelist = pagesLinkedList;
		
		if (nPagesInFreeList > maxFreeListAmount) {
			pageHeader* returnList = freelist->splitList(requestAmount);
			const uint32_t nReturned = nPagesInFreeList - requestAmount;
			returnPagesToGlobalPool(returnList, nReturned);			
			}
			
		dbg_dump_freelist();
		}
}
namespace stt
{
  void ThreadLocalPagePool::returnPagesToGlobalPool (pageHeader * returnList, uint32_t const nReturned)
                                                                                       {
		if (!returnList) return;
		nPagesInFreeList -= nReturned;
		// Return pages to main cache
		if (mPageType == pageTypeEnum::PAGE_TYPE_NORMAL)
			ThreadSafePageAllocatorImpl::get().PageGlobalFreeList.atomicMerge(returnList, nReturned);
		else if (mPageType == pageTypeEnum::PAGE_TYPE_JUMBO)
			ThreadSafePageAllocatorImpl::get().JumboGlobalFreeList.atomicMerge(returnList, nReturned);
		else
			STT_STL_ABORT();
		}
}
namespace stt
{
  PATL_Data::PATL_Data ()
                    {
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("CONSTRUCT NEW PATL_Data %p\n", this);
		#endif
		int threadId = ThreadLocalPagePool::staticNextId++;
		pageAlloc.init(pageTypeEnum::PAGE_TYPE_NORMAL, threadId);
		jumboPageAlloc.init(pageTypeEnum::PAGE_TYPE_NORMAL, threadId);
		}
}
namespace stt
{
  PATL_Data::~ PATL_Data ()
                     {
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("~PATL_Data %p\n", this);
		#endif
		}
}
namespace stt
{
  ThreadSafePageAllocatorImpl::ThreadSafePageAllocatorImpl ()
                                      {
		PageGlobalFreeList.mPageType = pageTypeEnum::PAGE_TYPE_NORMAL;
		JumboGlobalFreeList.mPageType = pageTypeEnum::PAGE_TYPE_JUMBO;
		
		initThreadLocalAllocators(); // init for this thread
		}
}
namespace stt
{
  ThreadSafePageAllocatorImpl::~ ThreadSafePageAllocatorImpl ()
                                       {
		cleanupGlobalFreeLists();
		}
}
namespace stt
{
  uint8_t * ThreadSafePageAllocatorImpl::raw_alloc (uint64_t const sz)
                                                     { return new uint8_t[sz]; }
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::raw_free (uint8_t * ptr, uint64_t const sz)
                                                              { delete[] ptr; }
}
namespace stt
{
  ThreadSafePageAllocatorImpl & ThreadSafePageAllocatorImpl::get ()
                                                  {
		static ThreadSafePageAllocatorImpl Instance;
		return Instance;
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::initThreadLocalAllocators ()
                                         {
		PATL_Data* r = mTls.getTlsData();
		if (!r)
			mTls.setTlsData(new PATL_Data);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::cleanupThreadLocalAllocators ()
                                            {
		PATL_Data* r = ThreadSafePageAllocatorImpl::get().mTls.getTlsData();
		if (r) delete r;
		mTls.setTlsData(NULL);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::cleanupGlobalFreeLists ()
                                      {
		PageGlobalFreeList.freeAll();
		JumboGlobalFreeList.freeAll();
		}
}
namespace stt
{
  PATL_Data * ThreadSafePageAllocatorImpl::getThreadLocalAllocators ()
                                              {
		return mTls.getTlsData();
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::allocPages (pageU * * pages, uint32_t const nPages)
                                                              {
		PATL_Data* LA = getThreadLocalAllocators();
		if (!LA) {
			// free after TL shutdown!
			perf_warning("PERF: allocPages() without thread_local pools, using global pool");
			PageGlobalFreeList.bulkFetch((pageHeader**) pages, nPages);
			return;
			}
		LA->pageAlloc.allocPages((pageHeader**) pages, nPages);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::freePages (pageU * * pages, uint32_t const nPages)
                                                             {
		PATL_Data* LA = getThreadLocalAllocators();
		if (!LA) {
			// free after TL shutdown!
			perf_warning("PERF: freePages() without thread_local pools, using global pool");
			PageGlobalFreeList.freePages((pageHeader**) pages, nPages);
			return;
			}
		LA->pageAlloc.freePages((pageHeader**) pages, nPages);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::freePagesList (pageU * pageList)
                                            {
		PATL_Data* LA = getThreadLocalAllocators();
		if (!LA) {
			// free after TL shutdown!
			perf_warning("PERF: freePagesList() without thread_local pools, using global pool");
			PageGlobalFreeList.atomicMerge((pageHeader*) pageList);
			return;
			}
		LA->pageAlloc.freePagesList((pageHeader*) pageList);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::allocJumboPages (pageU * * pages, uint32_t const nPages)
                                                                   {
		PATL_Data* LA = getThreadLocalAllocators();
		if (!LA) {
			// free after TL shutdown!
			perf_warning("PERF: allocJumboPages() without thread_local pools, using global pool");
			JumboGlobalFreeList.bulkFetch((pageHeader**) pages, nPages);
			return;
			}
		LA->jumboPageAlloc.allocPages((pageHeader**) pages, nPages);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::freeJumboPages (pageU * * pages, uint32_t const nPages)
                                                                  {
		PATL_Data* LA = getThreadLocalAllocators();
		if (!LA) {
			// free after TL shutdown!
			perf_warning("PERF: freeJumboPages() without thread_local pools, using global pool");
			JumboGlobalFreeList.freePages((pageHeader**) pages, nPages);
			return;
			}
		LA->jumboPageAlloc.freePages((pageHeader**) pages, nPages);
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::systemAllocate (pageTypeEnum const mPageType, uint32_t const nPagesTotal, uint32_t const nSplit, pageHeader * * groupA, pageHeader * * groupB)
                                                                                                                                                              {
		// Group A & B are pointers to pointers, NOT arrays of pointers
		if (mPageType == pageTypeEnum::PAGE_TYPE_NORMAL)
			systemAllocate_impl<pageU>(nPagesTotal, nSplit, groupA, groupB);
		else if (mPageType == pageTypeEnum::PAGE_TYPE_JUMBO)
			systemAllocate_impl<jumboPageU>(nPagesTotal, nSplit, groupA, groupB);
		else
			STT_STL_ABORT();
		}
}
namespace stt
{
  void ThreadSafePageAllocatorImpl::systemFreeList (pageHeader * head)
                                                     {
		#ifdef STT_DEBUG_PAGE
			uint32_t nPagesTotal = 0;
		#endif
		pageHeader* w = head;
		while (w) {
			pageHeader* n = w->next;
			raw_free((uint8_t*) w, 0);
			w = n;
			#ifdef STT_DEBUG_PAGE
				nPagesTotal++;
			#endif
			}
			
		#ifdef STT_DEBUG_PAGE
			stt_dbg_log("Freeing %i pages\n", nPagesTotal);
		#endif
		}
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_mt_page_allocator_impl
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// mt_page_allocator.hh
//

#ifndef LZZ_mt_page_allocator_hh
#define LZZ_mt_page_allocator_hh
#define LZZ_INLINE inline
namespace stt
{
  class ThreadSafePageAllocator
  {
  public:
    static void initThreadLocalAllocators ();
    static void cleanupThreadLocalAllocators ();
    static PATL_Data * getThreadLocalAllocators ();
    static pageU * allocPage ();
    static void freePage (pageU * page);
    static void allocPages (pageU * * pages, uint32_t const nPages);
    static void freePages (pageU * * pages, uint32_t const nPages);
    static void freePagesList (pageU * pageLinkedList);
  };
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    T * allocGeneric ();
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void freeGeneric (T * t);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void allocGenericBatch (T * * t, uint32_t const n);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void freeGenericBatch (T * * t, uint32_t const n);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void freeGenericList (T * t);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    pageU * allocGeneric ();
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    void freeGeneric (pageU * t);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    void allocGenericBatch (pageU * * t, uint32_t const n);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    void freeGenericBatch (pageU * * t, uint32_t const n);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    void freeGenericList (pageU * t);
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    T * allocGeneric ()
                                                    { STT_STL_ABORT(); return NULL; }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void freeGeneric (T * t)
                                                    { STT_STL_ABORT(); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void allocGenericBatch (T * * t, uint32_t const n)
                                                                             { STT_STL_ABORT(); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void freeGenericBatch (T * * t, uint32_t const n)
                                                                             { STT_STL_ABORT(); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <typename T>
    void freeGenericList (T * t)
                                                        { STT_STL_ABORT(); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    LZZ_INLINE pageU * allocGeneric ()
                                                     { return ThreadSafePageAllocator::allocPage(); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    LZZ_INLINE void freeGeneric (pageU * t)
                                                     { ThreadSafePageAllocator::freePage(t); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    LZZ_INLINE void allocGenericBatch (pageU * * t, uint32_t const n)
                                                                              { ThreadSafePageAllocator::allocPages(t, n); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    LZZ_INLINE void freeGenericBatch (pageU * * t, uint32_t const n)
                                                                              { ThreadSafePageAllocator::freePages(t, n); }
  }
}
namespace stt
{
  namespace ThreadSafePageAllocatorTemplates
  {
    template <>
    LZZ_INLINE void freeGenericList (pageU * t)
                                                         { ThreadSafePageAllocator::freePagesList(t); }
  }
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_mt_page_allocator
#define STT_STL_IMPL_DOUBLE_GUARD_mt_page_allocator
#define LZZ_OVERRIDE
// mt_page_allocator.cpp
//

#define LZZ_INLINE inline
namespace stt
{
  void ThreadSafePageAllocator::initThreadLocalAllocators ()
                                                {
		// MUST be called on thread startup!
		ThreadSafePageAllocatorImpl::get().initThreadLocalAllocators();
		}
}
namespace stt
{
  void ThreadSafePageAllocator::cleanupThreadLocalAllocators ()
                                                   {
		// MUST be called on thread end!
		ThreadSafePageAllocatorImpl::get().cleanupThreadLocalAllocators();
		}
}
namespace stt
{
  PATL_Data * ThreadSafePageAllocator::getThreadLocalAllocators ()
                                                     {
		return ThreadSafePageAllocatorImpl::get().getThreadLocalAllocators();
		}
}
namespace stt
{
  pageU * ThreadSafePageAllocator::allocPage ()
                                  {
		// Allocates a single pageU
		pageU* arr[1];
		ThreadSafePageAllocatorImpl::get().allocPages(&arr[0], 1);
		return arr[0];
		}
}
namespace stt
{
  void ThreadSafePageAllocator::freePage (pageU * page)
                                          {
		pageU* arr[1];
		arr[0] = page;
		ThreadSafePageAllocatorImpl::get().freePages(&arr[0], 1);
		}
}
namespace stt
{
  void ThreadSafePageAllocator::allocPages (pageU * * pages, uint32_t const nPages)
                                                                     { ThreadSafePageAllocatorImpl::get().allocPages(pages, nPages); }
}
namespace stt
{
  void ThreadSafePageAllocator::freePages (pageU * * pages, uint32_t const nPages)
                                                                     { ThreadSafePageAllocatorImpl::get().freePages(pages, nPages); }
}
namespace stt
{
  void ThreadSafePageAllocator::freePagesList (pageU * pageLinkedList)
                                                         { ThreadSafePageAllocatorImpl::get().freePagesList(pageLinkedList); }
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_mt_page_allocator
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// page_queue.hh
//

#ifndef LZZ_page_queue_hh
#define LZZ_page_queue_hh
namespace stt {
	template<typename T, typename P>
	struct pageQueueImpl;
	
	template <typename T>
	using pageQueue = pageQueueImpl<T,pageU>;
	}

#define STT_PAGEQUEUE_MVSEM pageQueueImpl&&
#define LZZ_INLINE inline
namespace stt
{
  template <typename T, typename P>
  struct pageQueueImpl
  {
    P * head;
    P * tail;
    struct iterator
    {
      T * ptr;
      T * localEnd;
      P * currentPage;
      uint32_t idx;
      void init (P * page);
      void incr ();
      void incr_nonInline ();
      typename pageQueueImpl <T,P>::iterator & operator ++ ();
      bool operator != (iterator const & other) const;
      T operator * ();
    };
    pageQueueImpl ();
    ~ pageQueueImpl ();
    void move_impl (STT_PAGEQUEUE_MVSEM other);
    pageQueueImpl (STT_PAGEQUEUE_MVSEM other);
    pageQueueImpl <T,P> & operator = (STT_PAGEQUEUE_MVSEM other);
  private:
    pageQueueImpl (pageQueueImpl const & other);
    pageQueueImpl & operator = (pageQueueImpl const & other);
  public:
    static P * allocPage ();
    static void freePage (P * page);
    static void freePagesList (P * pageList);
    static constexpr size_t pageLocalCapacity ();
    static constexpr T * pagePtr (P * const p);
    static constexpr T const * pagePtr (P const * const p);
    uint32_t size () const;
    void clear ();
    void clearKeepingFirstPage ();
    void swap (pageQueueImpl & other);
    void concatenate (STT_PAGEQUEUE_MVSEM other);
    void extendTailIfRequired ();
    void push_back (T const & t);
    void push_back (T&& t);
    iterator begin ();
    iterator end ();
  };
}
namespace stt
{
  class PageBumpAllocatedStorage
  {
  public:
    pageU * page;
    PageBumpAllocatedStorage ();
    ~ PageBumpAllocatedStorage ();
    template <typename T>
    static constexpr uint32_t roundedSizeOf ();
    bool contains (void * ptr) const;
    template <typename T>
    T * allocate ();
    template <typename T>
    void free (T * t);
    uint32_t getNumAllocations () const;
    uint32_t getFreeBytes () const;
  };
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::iterator::init (P * page)
                                           {
				currentPage = page;
				if (currentPage) {
					ptr = pageQueueImpl::pagePtr(currentPage);
					localEnd = &ptr[currentPage->ph.localSize];
					}
				else {
					ptr = NULL;
					localEnd = NULL;
					}
				}
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE void pageQueueImpl <T, P>::iterator::incr ()
                                           {
				if (ptr) // do not increment a null pointer
					ptr++;
				while (ptr == localEnd && currentPage) // if we are at the end of a page then increment to the next non-empty page
					incr_nonInline();
				}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::iterator::incr_nonInline ()
                                              {
				currentPage = (P*) currentPage->ph.next;
				if (currentPage) {
					ptr = pageQueueImpl::pagePtr(currentPage);
					localEnd = &ptr[currentPage->ph.localSize];
					}
				else {
					ptr = NULL;
					localEnd = NULL;
					}
				}
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE typename pageQueueImpl <T,P>::iterator & pageQueueImpl <T, P>::iterator::operator ++ ()
                                                                                   {
				incr();
				return *this;
				}
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE bool pageQueueImpl <T, P>::iterator::operator != (iterator const & other) const
                                                                             { return ptr != other.ptr; }
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE T pageQueueImpl <T, P>::iterator::operator * ()
                                              { return *ptr; }
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE pageQueueImpl <T, P>::pageQueueImpl ()
    : head (NULL), tail (NULL)
                                                                 {}
}
namespace stt
{
  template <typename T, typename P>
  pageQueueImpl <T, P>::~ pageQueueImpl ()
                                 { clear(); }
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE void pageQueueImpl <T, P>::move_impl (STT_PAGEQUEUE_MVSEM other)
                                                                 { head = other.head; tail = other.tail; other.head = NULL; other.tail = NULL; }
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE pageQueueImpl <T, P>::pageQueueImpl (STT_PAGEQUEUE_MVSEM other)
                                                                { move_impl(std::move(other)); }
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE pageQueueImpl <T,P> & pageQueueImpl <T, P>::operator = (STT_PAGEQUEUE_MVSEM other)
                                                                                 { clear(); move_impl(std::move(other)); return *this; }
}
namespace stt
{
  template <typename T, typename P>
  P * pageQueueImpl <T, P>::allocPage ()
                                       {
			P* p = ThreadSafePageAllocatorTemplates::allocGeneric<P>();
			p->initHeader();
			return p;
			}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::freePage (P * page)
                                              {
			ThreadSafePageAllocatorTemplates::freeGeneric<P>(page);
			}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::freePagesList (P * pageList)
                                                       {
			ThreadSafePageAllocatorTemplates::freeGenericList<P>(pageList);
			}
}
namespace stt
{
  template <typename T, typename P>
  constexpr size_t pageQueueImpl <T, P>::pageLocalCapacity ()
                                                                         { return P::capacity() / sizeof(T);  }
}
namespace stt
{
  template <typename T, typename P>
  constexpr T * pageQueueImpl <T, P>::pagePtr (P * const p)
                                                                         { return (T*) &p->_data[STT_PAGE_HEADER_SIZE]; }
}
namespace stt
{
  template <typename T, typename P>
  constexpr T const * pageQueueImpl <T, P>::pagePtr (P const * const p)
                                                                         { return (const T*) &p->_data[STT_PAGE_HEADER_SIZE]; }
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE uint32_t pageQueueImpl <T, P>::size () const
                                             { return head ? head->ph.totalSize : 0; }
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::clear ()
                             {
			if constexpr(std::is_trivially_destructible<T>::value) {
				// we don't need to invoke destructors so we can just throw away the linked list
				if (head) {
					head->ph.cachedWorkingEnd = (pageHeader*) tail;
					freePagesList(head);
					}
				}
			else {
				// we need to itterate through the linked list and destroy every object
				P* w = head;
				while (w) {
					P* t = w;
					w = (P*) w->ph.next;
					for (uint32_t i = 0; i < t.ph.localSize; ++i)
						pagePtr(t)[i].~T();
					freePage(t);
					}
				}
			head = NULL;
			tail = NULL;
			}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::clearKeepingFirstPage ()
                                             {
			// Clears the pageQueue but keeps the first page
			if (head && head->next) {
				pageQueueImpl tmp;
				tmp.head = head->next;
				tmp.head->ph.cachedWorkingEnd = tail;
				tmp.tail = tail;
				tmp.clear();
				head = NULL;
				tail = head; 
				}
			}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::swap (pageQueueImpl & other)
                                                {
			std::swap(head, other.head);
			std::swap(tail, other.tail);
			}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::concatenate (STT_PAGEQUEUE_MVSEM other)
                                                            {
			// transfers the other queue to the end of this
			if (!other.head)
				return;
			if (tail) {
				tail->ph.next = (pageHeader*) other.head;
				tail = other.tail;
				}
			else {
				head = other.head;
				tail = other.tail;
				}
			other.head = NULL;
			other.tail = NULL;
			}
}
namespace stt
{
  template <typename T, typename P>
  void pageQueueImpl <T, P>::extendTailIfRequired ()
                                            {
			if (!tail) {
				head = allocPage();
				tail = head;
				}
			if (tail->ph.localSize >= pageLocalCapacity()) {
				tail->ph.next = (pageHeader*) allocPage();
				tail = (P*) tail->ph.next;
				}
			}
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE void pageQueueImpl <T, P>::push_back (T const & t)
                                                  {
			extendTailIfRequired();
			new (&(pageQueueImpl::pagePtr(tail)[tail->ph.localSize])) T(t);
			tail->ph.localSize++;
			head->ph.totalSize++;
			}
}
namespace stt
{
  template <typename T, typename P>
  LZZ_INLINE void pageQueueImpl <T, P>::push_back (T&& t)
                                                  {
			stt_dbg_log("move semantics!\n");
			extendTailIfRequired();
			new (&(pageQueueImpl::pagePtr(tail)[tail->ph.localSize])) T(std::move(t));
			tail->ph.localSize++;
			head->ph.totalSize++;
			}
}
namespace stt
{
  template <typename T, typename P>
  typename pageQueueImpl <T, P>::iterator pageQueueImpl <T, P>::begin ()
                                 {
			iterator it;
			it.init(head);
			return  it;
			}
}
namespace stt
{
  template <typename T, typename P>
  typename pageQueueImpl <T, P>::iterator pageQueueImpl <T, P>::end ()
                               {
			iterator it;
			it.init(NULL);
			return  it;
			}
}
namespace stt
{
  template <typename T>
  LZZ_INLINE constexpr uint32_t PageBumpAllocatedStorage::roundedSizeOf ()
                                                                      { return sizeof(T); }
}
namespace stt
{
  LZZ_INLINE bool PageBumpAllocatedStorage::contains (void * ptr) const
                                                      {
			uintptr_t pagei = uintptr_t(page);
			uintptr_t ptri = uintptr_t(ptr);
			return (ptri >= pagei) && (pagei < pagei + page->storageSize());
			}
}
namespace stt
{
  template <typename T>
  T * PageBumpAllocatedStorage::allocate ()
                              {
			T* r = (T*) &(page->ptr()[page->ph.localSize]);
			page->ph.localSize += roundedSizeOf<T>();
			page->ph.totalSize++;
			new (r) T();
			return r;
			}
}
namespace stt
{
  template <typename T>
  void PageBumpAllocatedStorage::free (T * t)
                                {
			if (page->ph.localSize == (uintptr_t(t) - uintptr_t(page)) + roundedSizeOf<T>()) {
				page->ph.localSize -= sizeof(T);
				}
			page->ph.totalSize--;
			t->~T();
			}
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_page_queue
#define STT_STL_IMPL_DOUBLE_GUARD_page_queue
#define LZZ_OVERRIDE
// page_queue.cpp
//

#define LZZ_INLINE inline
namespace stt
{
  PageBumpAllocatedStorage::PageBumpAllocatedStorage ()
                                           {
			page = ThreadSafePageAllocator::allocPage();
			page->initHeader();
			}
}
namespace stt
{
  PageBumpAllocatedStorage::~ PageBumpAllocatedStorage ()
                                            {
			STT_STL_ASSERT(page->ph.totalSize == 0, ""); //remaning allocations
			ThreadSafePageAllocator::freePage(page);
			page = NULL;
			}
}
namespace stt
{
  uint32_t PageBumpAllocatedStorage::getNumAllocations () const
                                                   { return page->ph.totalSize; }
}
namespace stt
{
  uint32_t PageBumpAllocatedStorage::getFreeBytes () const
                                              { return page->capacity() - page->ph.localSize; }
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_page_queue
#endif //STT_STL_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// page.hh
//

#ifndef LZZ_page_hh
#define LZZ_page_hh
#ifndef STT_PAGE_HEADER_SIZE
	#define STT_PAGE_HEADER_SIZE 64
#endif
#ifndef STT_PAGE_SIZE
	#define STT_PAGE_SIZE 4080	// this makes alignement better 
#endif
#ifndef STT_JUMBO_PAGE_SIZE
	#define STT_JUMBO_PAGE_SIZE 65520
#endif

	
#define LZZ_INLINE inline
namespace stt
{
  enum pageTypeEnum
  {
    PAGE_TYPE_NORMAL,
    PAGE_TYPE_JUMBO,
    PAGE_TYPE_UNSET
  };
}
namespace stt
{
  char const * pageTypeEnumToString (pageTypeEnum const pt);
}
namespace stt
{
  struct pageHeader
  {
    pageHeader * next;
    pageHeader * cachedWorkingEnd;
    uint64_t allocationInfo;
    uint32_t localSize;
    uint32_t totalSize;
    uint64_t useMask;
    uint64_t (_unused) [3];
    void initToZero ();
    void appendList (pageHeader * other);
    pageHeader * splitList (uint32_t const nPages);
    static pageHeader * buildList (pageHeader * * pages, uint32_t const nPages);
    pageHeader * end ();
    pageHeader * endCounting (int & countOut);
    int listLength ();
    uint8_t * toPayload ();
    static pageHeader * fromPayload (uint8_t * ptr);
  };
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  union pageTemplate
  {
    pageHeader ph;
    uint8_t (_data) [STT_PAGE_SIZE];
    void initHeader ();
    constexpr uint8_t * ptr ();
    constexpr uint8_t const * ptr () const;
    static constexpr size_t capacity ();
    static constexpr size_t storageSize ();
    static constexpr pageTypeEnum getPageType ();
  };
}
namespace stt
{
  typedef pageTemplate <STT_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_NORMAL> pageU;
}
namespace stt
{
  typedef pageTemplate <STT_JUMBO_PAGE_SIZE, pageTypeEnum::PAGE_TYPE_JUMBO> jumboPageU;
}
namespace stt
{
  LZZ_INLINE void pageHeader::initToZero ()
                                         {
			//allocator = NULL;
			next = NULL;
			cachedWorkingEnd = NULL;
			allocationInfo = 0;
			localSize = 0;
			totalSize = 0;
			useMask = 0;
			}
}
namespace stt
{
  LZZ_INLINE uint8_t * pageHeader::toPayload ()
                                            {
			uint8_t* ptr = (uint8_t*) this;
			return &ptr[STT_PAGE_HEADER_SIZE];
			}
}
namespace stt
{
  LZZ_INLINE pageHeader * pageHeader::fromPayload (uint8_t * ptr)
                                                                    {
			// Reverse operation of pageU::ptr(), takes a page's data pointer and returns the address of the header
			return (pageHeader*) &ptr[-STT_PAGE_HEADER_SIZE];
			}
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  LZZ_INLINE void pageTemplate <SIZE, ET>::initHeader ()
                                         { ph.initToZero(); ph.allocationInfo = SIZE; }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr uint8_t * pageTemplate <SIZE, ET>::ptr ()
                                                          { return &_data[STT_PAGE_HEADER_SIZE]; }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr uint8_t const * pageTemplate <SIZE, ET>::ptr () const
                                                          { return &_data[STT_PAGE_HEADER_SIZE]; }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr size_t pageTemplate <SIZE, ET>::capacity ()
                                                        { return SIZE - STT_PAGE_HEADER_SIZE;  }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr size_t pageTemplate <SIZE, ET>::storageSize ()
                                                           { return SIZE;  }
}
namespace stt
{
  template <unsigned int SIZE, pageTypeEnum ET>
  constexpr pageTypeEnum pageTemplate <SIZE, ET>::getPageType ()
                                                                 { return ET; }
}
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_page
#define STT_STL_IMPL_DOUBLE_GUARD_page
#define LZZ_OVERRIDE
// page.cpp
//


namespace stt {
	static_assert(sizeof(pageHeader) <= STT_PAGE_HEADER_SIZE);
	}
#define LZZ_INLINE inline
namespace stt
{
  char const * pageTypeEnumToString (pageTypeEnum const pt)
                                                                 {
		switch (pt) {
			case pageTypeEnum::PAGE_TYPE_NORMAL: return "Normal";
			case pageTypeEnum::PAGE_TYPE_JUMBO: return "Jumbo";
			default: return "Unset";
			}
		}
}
namespace stt
{
  void pageHeader::appendList (pageHeader * other)
                                                   {
			// appends other to this list
			// assumes cachedWorkingEnd is a valid value for both this and othe
			// assumes other is not null
			cachedWorkingEnd->next = other;
			cachedWorkingEnd = other->cachedWorkingEnd;
			}
}
namespace stt
{
  pageHeader * pageHeader::splitList (uint32_t const nPages)
                                                             {
			// assumes cachedWorkingEnd is a valid value for this
			// if this is too short then returns NULL
			pageHeader* w = this;
			uint32_t cnt = 1;
			while (w->next && (cnt < nPages)) {
				cnt++;
				w = w->next;
				}
			// w should now be the end of this list
			// and w->next should be the start of next
			if (!w) return NULL; // fail split
			if (!w->next) return NULL; // fail split
			
			pageHeader* r = w->next;
			r->cachedWorkingEnd = cachedWorkingEnd;
			w->next = NULL;
			cachedWorkingEnd = w;
			return r;
			}
}
namespace stt
{
  pageHeader * pageHeader::buildList (pageHeader * * pages, uint32_t const nPages)
                                                                                        {
			// assembles pages into a linked list, returns the head
			if (!nPages) return NULL;
			for (uint32_t i = 0; i < nPages-1; ++i) {
				pages[i]->next = pages[i+1];
				}
			pages[nPages-1]->next = NULL;
			pages[0]->cachedWorkingEnd = pages[nPages-1];
			return pages[0];
			}
}
namespace stt
{
  pageHeader * pageHeader::end ()
                                  {
			// manually traverses to the end
			pageHeader* w = this;
			while (w) { w = w->next; }
			return w;
			}
}
namespace stt
{
  pageHeader * pageHeader::endCounting (int & countOut)
                                                       {
			// manually traverses to the end, counts number of pages
			pageHeader* w = this;
			while (w) { countOut++; w = w->next; }
			return w;
			}
}
namespace stt
{
  int pageHeader::listLength ()
                                 {
			int cnt = 0;
			endCounting(cnt);
			return cnt;
			}
}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_page
#endif //STT_STL_IMPL_IMPL
