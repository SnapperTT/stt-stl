// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// example_pages.hh
//

#ifndef LZZ_example_pages_hh
#define LZZ_example_pages_hh
//#define STT_STL_DEBUG 1
//#define STT_STL_DEBUG_MEMORY 1
//#define STT_STL_DEBUG_PAGE 1
#include "stt-stl.h"
#define STT_STL_IMPL 1
#define LZZ_INLINE inline
struct biglyInt
{
  int64_t value;
  int64_t (padding) [63];
};
int main (int argc, char * * argv);
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_example_pages
#define STT_STL_IMPL_DOUBLE_GUARD_example_pages
#define LZZ_OVERRIDE
// example_pages.cpp
//

#define STT_STL_IMPL 1
#include "stt-stl.h"
#include "stt-pages.h"

#include <iostream>
#define LZZ_INLINE inline
int main (int argc, char * * argv)
                                  {
	stt::ThreadSafePageAllocator::initThreadLocalPools(); // must be called at the start of the thread
	
	// allocate and destroy some stuff
	stt::pageU* p = stt::ThreadSafePageAllocator::allocPage();
	stt::pageU* pp[13];
	stt::ThreadSafePageAllocator::allocPages(&pp[0], 13);
	stt::ThreadSafePageAllocator::freePage(p);
	stt::ThreadSafePageAllocator::freePages(&pp[0], 13);
	
	// test a page queue
	{
	stt::pageQueue<biglyInt> pq;
	stt::stt_dbg_log("Pushing back into pq....\n");
	for (int i = 0; i < 10; ++i) {
		biglyInt bi; bi.value = i;
		pq.push_back(std::move(bi));
		}
	
	printf("pq values....\n");
	for (const biglyInt& a : pq)
		stt::stt_dbg_log("\t%li\n", a.value);
		
	for (auto itt = pq.begin() ; itt != pq.end(); ++itt) {
		stt::stt_dbg_log("\t%p: %li\n", itt.currentPage, (*itt).value);
		}
	}
	
	
	// test a page-based allocator and interning data within
	{
		stt::string24 testStr = "The quick brown fox jumped over the lazy log 1234567890abcdefghijklmnopqrstuvwxyz";
		stt::pageQueueBumpStorage<stt::pageU> store;
		
		stt::vector24<stt::string_view> svs;
		svs.setAllocator(&store);
		
		// using a hint can speed up push_back_compact in a loop
		stt::pageQueueBumpStorage<stt::pageU>::pushBackLookupHint mHint;
		
		for (uint i = 0; i < 100; ++i) {
			svs.push_back(store.push_back_compact(testStr, &mHint));
			stt::stt_dbg_log("INSERT: %i svs: [%p, %i] %s\n", i, svs[i].data(), int(svs[i].size()), svs[i].data());
			}
		
		for (uint i = 0; i < 100; ++i) {
			stt::stt_dbg_log("READ: %i svs: [%p, %i] %s\n", i, svs[i].data(), int(svs[i].size()), svs[i].data());
			}
	}

	// Cleanup - 
	// If you are exiting the program you can just ::exit() and forgo cleanup
	
	stt::ThreadSafePageAllocator::cleanupThreadLocalPools(); // must be called at the end of a thread, this call cleans up *this* thread's pool
	stt::ThreadSafePageAllocator::cleanupBackendPools(); // must be called on program shutdown to free all pages in the backend pool to system memory
	return 1;
	}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_example_pages
#endif //STT_STL_IMPL_IMPL
