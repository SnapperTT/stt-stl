// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
#ifndef LZZ_OVERRIDE
	#define LZZ_OVERRIDE override
#endif
// example_pages.hh
//

#ifndef LZZ_example_pages_hh
#define LZZ_example_pages_hh
#define STT_STL_DEBUG 1
#define STT_STL_DEBUG_MEMORY 1
#define STT_STL_DEBUG_PAGE 1
#include "stt-stl.h"
#define STT_STL_IMPL 1
#define LZZ_INLINE inline
struct biglyInt
{
  int64_t value;
  int64_t (padding) [63];
};
int main (int argc, char * * argv);
#undef LZZ_INLINE
#endif
#undef LZZ_OVERRIDE

////////////////////////////////////////////////////////////////////////

#ifdef STT_STL_IMPL
#ifndef STT_STL_IMPL_DOUBLE_GUARD_example_pages
#define STT_STL_IMPL_DOUBLE_GUARD_example_pages
#define LZZ_OVERRIDE
// example_pages.cpp
//

#define STT_STL_IMPL 1
#include "stt-stl.h"
#include "stt-pages.h"

#include <iostream>
#define LZZ_INLINE inline
int main (int argc, char * * argv)
                                  {
	stt::ThreadSafePageAllocator::initThreadLocalAllocators(); // must be called at the start of the thread
	
	// allocate and destroy some stuff
	stt::pageU* p = stt::ThreadSafePageAllocator::allocPage();
	stt::pageU* pp[13];
	stt::ThreadSafePageAllocator::allocPages(&pp[0], 13);
	stt::ThreadSafePageAllocator::freePage(p);
	stt::ThreadSafePageAllocator::freePages(&pp[0], 13);
	
	// test a page queue
	{
	stt::pageQueue<biglyInt> pq;
	stt::stt_dbg_log("Pushing back into pq....\n");
	for (int i = 0; i < 10; ++i) {
		biglyInt bi; bi.value = i;
		pq.push_back(std::move(bi));
		}
	
	printf("pq values....\n");
	for (const biglyInt& a : pq)
		stt::stt_dbg_log("\t%li\n", a.value);
		
	for (auto itt = pq.begin() ; itt != pq.end(); ++itt) {
		stt::stt_dbg_log("\t%p: %li\n", itt.currentPage, (*itt).value);
		}
	}
	
	stt::stt_dbg_log("sizeof string128 %i\n", sizeof(stt::string128));
	stt::stt_dbg_log("sizeof string254 %i\n", sizeof(stt::string256));
	
	stt::ThreadSafePageAllocator::cleanupThreadLocalAllocators(); // must be called at the end of the thread
	stt::ThreadSafePageAllocatorImpl::get().cleanupGlobalFreeLists(); // must be called on program shutdown to free
	return 1;
	}
#undef LZZ_INLINE
#undef LZZ_OVERRIDE
#endif //STT_STL_IMPL_DOUBLE_GUARD_example_pages
#endif //STT_STL_IMPL_IMPL
